function SpectreTab(e, t) {
    e && e.addEventListener("click", function(s) {
        if (s.preventDefault(), t.resetTabState_(), t.resetPanelState_(), t.resetLine_(e), 
        e.classList.add(t.CssClasses_.ACTIVE_CLASS), e.href) {
            var n = e.href.split("#")[1], i = t.element_.querySelector("#" + n);
            i && i.classList.add(t.CssClasses_.ACTIVE_CLASS);
        }
    });
}

!function(window, undefined) {
    "use strict";
    function mkitem(expr, key, val) {
        var item = {};
        return item[expr.key] = key, expr.pos && (item[expr.pos] = val), item;
    }
    function unmountRedundant(items, tags) {
        for (var t, i = tags.length, j = items.length; i > j; ) t = tags[--i], tags.splice(i, 1), 
        t.unmount();
    }
    function moveNestedTags(child, i) {
        Object.keys(child.tags).forEach(function(tagName) {
            var tag = child.tags[tagName];
            isArray(tag) ? each(tag, function(t) {
                moveChildTag(t, tagName, i);
            }) : moveChildTag(tag, tagName, i);
        });
    }
    function addVirtual(tag, src, target) {
        var sib, el = tag._root;
        for (tag._virts = []; el; ) sib = el.nextSibling, target ? src.insertBefore(el, target._root) : src.appendChild(el), 
        tag._virts.push(el), el = sib;
    }
    function moveVirtual(tag, src, target, len) {
        for (var sib, el = tag._root, i = 0; i < len; i++) sib = el.nextSibling, src.insertBefore(el, target._root), 
        el = sib;
    }
    function insertTag(isVirtual, prevTag, newTag, root, tags, virtualFn, dom) {
        isInStub(prevTag.root) || (isVirtual ? virtualFn(prevTag, root, newTag, dom.childNodes.length) : root.insertBefore(prevTag.root, newTag.root));
    }
    function _each(dom, parent, expr) {
        remAttr(dom, "each");
        var hasKeys, mustReorder = typeof getAttr(dom, "no-reorder") !== T_STRING || remAttr(dom, "no-reorder"), tagName = getTagName(dom), impl = __tagImpl[tagName] || {
            tmpl: getOuterHTML(dom)
        }, useRoot = SPECIAL_TAGS_REGEX.test(tagName), root = dom.parentNode, ref = document.createTextNode(""), child = getTag(dom), isOption = "option" === tagName.toLowerCase(), tags = [], oldItems = [], isVirtual = "VIRTUAL" == dom.tagName;
        expr = tmpl.loopKeys(expr), root.insertBefore(ref, dom), parent.one("before-mount", function() {
            dom.parentNode.removeChild(dom), root.stub && (root = parent.root);
        }).on("update", function() {
            var items = tmpl(expr.val, parent), frag = document.createDocumentFragment();
            isArray(items) || (hasKeys = items || !1, items = hasKeys ? Object.keys(items).map(function(key) {
                return mkitem(expr, key, items[key]);
            }) : []);
            for (var i = 0, itemsLength = items.length; i < itemsLength; i++) {
                var item = items[i], _mustReorder = mustReorder && typeof item == T_OBJECT && !hasKeys, oldPos = oldItems.indexOf(item), pos = ~oldPos && _mustReorder ? oldPos : i, tag = tags[pos];
                item = !hasKeys && expr.key ? mkitem(expr, item, i) : item, !_mustReorder && !tag || _mustReorder && !~oldPos || !tag ? (tag = new Tag(impl, {
                    parent: parent,
                    isLoop: !0,
                    hasImpl: !!__tagImpl[tagName],
                    root: useRoot ? root : dom.cloneNode(),
                    item: item
                }, dom.innerHTML), tag.mount(), isVirtual && (tag._root = tag.root.firstChild), 
                i != tags.length && tags[i] ? (insertTag(isVirtual, tag, tags[i], root, tags, addVirtual, dom), 
                oldItems.splice(i, 0, item)) : isVirtual ? addVirtual(tag, frag) : frag.appendChild(tag.root), 
                tags.splice(i, 0, tag), pos = i) : tag.update(item, !0), pos !== i && _mustReorder && tags[i] && (contains(items, oldItems[i]) && insertTag(isVirtual, tag, tags[i], root, tags, moveVirtual, dom), 
                expr.pos && (tag[expr.pos] = i), tags.splice(i, 0, tags.splice(pos, 1)[0]), oldItems.splice(i, 0, oldItems.splice(pos, 1)[0]), 
                !child && tag.tags && moveNestedTags(tag, i)), tag._item = item, defineProperty(tag, "_parent", parent);
            }
            if (unmountRedundant(items, tags), root.insertBefore(frag, ref), isOption && FIREFOX && !root.multiple) for (var n = 0; n < root.length; n++) if (root[n].__riot1374) {
                root.selectedIndex = n, delete root[n].__riot1374;
                break;
            }
            child && (parent.tags[tagName] = tags), oldItems = items.slice();
        });
    }
    function parseNamedElements(root, tag, childTags, forceParsingNamed) {
        walk(root, function(dom) {
            if (1 == dom.nodeType) {
                if (dom.isLoop = dom.isLoop || dom.parentNode && dom.parentNode.isLoop || getAttr(dom, "each") ? 1 : 0, 
                childTags) {
                    var child = getTag(dom);
                    child && !dom.isLoop && childTags.push(initChildTag(child, {
                        root: dom,
                        parent: tag
                    }, dom.innerHTML, tag));
                }
                dom.isLoop && !forceParsingNamed || setNamed(dom, tag, []);
            }
        });
    }
    function parseExpressions(root, tag, expressions) {
        function addExpr(dom, val, extra) {
            tmpl.hasExpr(val) && expressions.push(extend({
                dom: dom,
                expr: val
            }, extra));
        }
        walk(root, function(dom) {
            var attr, type = dom.nodeType;
            if (3 == type && "STYLE" != dom.parentNode.tagName && addExpr(dom, dom.nodeValue), 
            1 == type) return (attr = getAttr(dom, "each")) ? (_each(dom, tag, attr), !1) : (each(dom.attributes, function(attr) {
                var name = attr.name, bool = name.split("__")[1];
                if (addExpr(dom, attr.value, {
                    attr: bool || name,
                    bool: bool
                }), bool) return remAttr(dom, name), !1;
            }), !getTag(dom) && void 0);
        });
    }
    function Tag(impl, conf, innerHTML) {
        function updateOpts() {
            var ctx = hasImpl && isLoop ? self : parent || self;
            each(root.attributes, function(el) {
                var val = el.value;
                opts[toCamel(el.name)] = tmpl.hasExpr(val) ? tmpl(val, ctx) : val;
            }), each(Object.keys(attr), function(name) {
                opts[toCamel(name)] = tmpl(attr[name], ctx);
            });
        }
        function normalizeData(data) {
            for (var key in item) typeof self[key] !== T_UNDEF && isWritable(self, key) && (self[key] = data[key]);
        }
        function inheritFrom(target) {
            each(Object.keys(target), function(k) {
                var mustSync = !RESERVED_WORDS_BLACKLIST.test(k) && contains(propsInSyncWithParent, k);
                (typeof self[k] === T_UNDEF || mustSync) && (mustSync || propsInSyncWithParent.push(k), 
                self[k] = target[k]);
            });
        }
        function onChildUpdate(data) {
            self.update(data, !0);
        }
        function toggle(isMount) {
            if (each(childTags, function(child) {
                child[isMount ? "mount" : "unmount"]();
            }), parent) {
                var evt = isMount ? "on" : "off";
                isLoop ? parent[evt]("unmount", self.unmount) : parent[evt]("update", onChildUpdate)[evt]("unmount", self.unmount);
            }
        }
        var dom, self = riot.observable(this), opts = inherit(conf.opts) || {}, parent = conf.parent, isLoop = conf.isLoop, hasImpl = conf.hasImpl, item = cleanUpData(conf.item), expressions = [], childTags = [], root = conf.root, tagName = root.tagName.toLowerCase(), attr = {}, propsInSyncWithParent = [];
        impl.name && root._tag && root._tag.unmount(!0), this.isMounted = !1, root.isLoop = isLoop, 
        root._tag = this, defineProperty(this, "_riot_id", ++__uid), extend(this, {
            parent: parent,
            root: root,
            opts: opts
        }, item), defineProperty(this, "tags", {}), each(root.attributes, function(el) {
            var val = el.value;
            tmpl.hasExpr(val) && (attr[el.name] = val);
        }), dom = mkdom(impl.tmpl, innerHTML, isLoop), defineProperty(this, "update", function(data, isInherited) {
            return data = cleanUpData(data), isLoop && inheritFrom(self.parent), data && isObject(item) && (normalizeData(data), 
            item = data), extend(self, data), updateOpts(), self.trigger("update", data), update(expressions, self), 
            isInherited && self.parent ? self.parent.one("updated", function() {
                self.trigger("updated");
            }) : rAF(function() {
                self.trigger("updated");
            }), this;
        }), defineProperty(this, "mixin", function() {
            return each(arguments, function(mix) {
                var instance, obj, props = [];
                mix = typeof mix === T_STRING ? riot.mixin(mix) : mix, instance = isFunction(mix) ? new mix() : mix;
                var proto = Object.getPrototypeOf(instance);
                do props = props.concat(Object.getOwnPropertyNames(obj || instance)); while (obj = Object.getPrototypeOf(obj || instance));
                each(props, function(key) {
                    if ("init" != key) {
                        var descriptor = Object.getOwnPropertyDescriptor(instance, key) || Object.getOwnPropertyDescriptor(proto, key), hasGetterSetter = descriptor && (descriptor.get || descriptor.set);
                        !self.hasOwnProperty(key) && hasGetterSetter ? Object.defineProperty(self, key, descriptor) : self[key] = isFunction(instance[key]) ? instance[key].bind(self) : instance[key];
                    }
                }), instance.init && instance.init.bind(self)();
            }), this;
        }), defineProperty(this, "mount", function() {
            updateOpts();
            var globalMixin = riot.mixin(GLOBAL_MIXIN);
            if (globalMixin) for (var i in globalMixin) globalMixin.hasOwnProperty(i) && self.mixin(globalMixin[i]);
            if (self._parent && self._parent.root.isLoop && inheritFrom(self._parent), impl.fn && impl.fn.call(self, opts), 
            parseExpressions(dom, self, expressions), toggle(!0), impl.attrs && walkAttributes(impl.attrs, function(k, v) {
                setAttr(root, k, v);
            }), (impl.attrs || hasImpl) && parseExpressions(self.root, self, expressions), self.parent && !isLoop || self.update(item), 
            self.trigger("before-mount"), isLoop && !hasImpl) root = dom.firstChild; else {
                for (;dom.firstChild; ) root.appendChild(dom.firstChild);
                root.stub && (root = parent.root);
            }
            defineProperty(self, "root", root), isLoop && parseNamedElements(self.root, self.parent, null, !0), 
            !self.parent || self.parent.isMounted ? (self.isMounted = !0, self.trigger("mount")) : self.parent.one("mount", function() {
                isInStub(self.root) || (self.parent.isMounted = self.isMounted = !0, self.trigger("mount"));
            });
        }), defineProperty(this, "unmount", function(keepRootTag) {
            var ptag, el = root, p = el.parentNode, tagIndex = __virtualDom.indexOf(self);
            if (self.trigger("before-unmount"), ~tagIndex && __virtualDom.splice(tagIndex, 1), 
            p) {
                if (parent) ptag = getImmediateCustomParentTag(parent), isArray(ptag.tags[tagName]) ? each(ptag.tags[tagName], function(tag, i) {
                    tag._riot_id == self._riot_id && ptag.tags[tagName].splice(i, 1);
                }) : ptag.tags[tagName] = undefined; else for (;el.firstChild; ) el.removeChild(el.firstChild);
                keepRootTag ? (remAttr(p, RIOT_TAG_IS), remAttr(p, RIOT_TAG)) : p.removeChild(el);
            }
            this._virts && each(this._virts, function(v) {
                v.parentNode && v.parentNode.removeChild(v);
            }), self.trigger("unmount"), toggle(), self.off("*"), self.isMounted = !1, delete root._tag;
        }), parseNamedElements(dom, this, childTags);
    }
    function setEventHandler(name, handler, dom, tag) {
        dom[name] = function(e) {
            var el, ptag = tag._parent, item = tag._item;
            if (!item) for (;ptag && !item; ) item = ptag._item, ptag = ptag._parent;
            e = e || window.event, isWritable(e, "currentTarget") && (e.currentTarget = dom), 
            isWritable(e, "target") && (e.target = e.srcElement), isWritable(e, "which") && (e.which = e.charCode || e.keyCode), 
            e.item = item, handler.call(tag, e) === !0 || /radio|check/.test(dom.type) || (e.preventDefault && e.preventDefault(), 
            e.returnValue = !1), e.preventUpdate || (el = item ? getImmediateCustomParentTag(ptag) : tag, 
            el.update());
        };
    }
    function insertTo(root, node, before) {
        root && (root.insertBefore(before, node), root.removeChild(node));
    }
    function update(expressions, tag) {
        each(expressions, function(expr, i) {
            var dom = expr.dom, attrName = expr.attr, value = tmpl(expr.expr, tag), parent = expr.parent || expr.dom.parentNode;
            if (expr.bool ? value = !!value : null == value && (value = ""), expr.value !== value) {
                if (expr.value = value, !attrName) return value += "", void (parent && (expr.parent = parent, 
                "TEXTAREA" === parent.tagName ? (parent.value = value, IE_VERSION || (dom.nodeValue = value)) : dom.nodeValue = value));
                if ("value" === attrName) return void (dom.value !== value && (dom.value = value, 
                setAttr(dom, attrName, value)));
                if (remAttr(dom, attrName), isFunction(value)) setEventHandler(attrName, value, dom, tag); else if ("if" == attrName) {
                    var stub = expr.stub, add = function() {
                        insertTo(stub.parentNode, stub, dom);
                    }, remove = function() {
                        insertTo(dom.parentNode, dom, stub);
                    };
                    value ? stub && (add(), dom.inStub = !1, isInStub(dom) || walk(dom, function(el) {
                        el._tag && !el._tag.isMounted && (el._tag.isMounted = !!el._tag.trigger("mount"));
                    })) : (stub = expr.stub = stub || document.createTextNode(""), dom.parentNode ? remove() : (tag.parent || tag).one("updated", remove), 
                    dom.inStub = !0);
                } else "show" === attrName ? dom.style.display = value ? "" : "none" : "hide" === attrName ? dom.style.display = value ? "none" : "" : expr.bool ? (dom[attrName] = value, 
                value && setAttr(dom, attrName, attrName), FIREFOX && "selected" === attrName && "OPTION" === dom.tagName && (dom.__riot1374 = value)) : (0 === value || value && typeof value !== T_OBJECT) && (startsWith(attrName, RIOT_PREFIX) && attrName != RIOT_TAG && (attrName = attrName.slice(RIOT_PREFIX.length)), 
                setAttr(dom, attrName, value));
            }
        });
    }
    function each(els, fn) {
        for (var el, len = els ? els.length : 0, i = 0; i < len; i++) el = els[i], null != el && fn(el, i) === !1 && i--;
        return els;
    }
    function isFunction(v) {
        return typeof v === T_FUNCTION || !1;
    }
    function getOuterHTML(el) {
        if (el.outerHTML) return el.outerHTML;
        var container = mkEl("div");
        return container.appendChild(el.cloneNode(!0)), container.innerHTML;
    }
    function setInnerHTML(container, html) {
        if (typeof container.innerHTML != T_UNDEF) container.innerHTML = html; else {
            var doc = new DOMParser().parseFromString(html, "application/xml");
            container.appendChild(container.ownerDocument.importNode(doc.documentElement, !0));
        }
    }
    function isSVGTag(name) {
        return ~SVG_TAGS_LIST.indexOf(name);
    }
    function isObject(v) {
        return v && typeof v === T_OBJECT;
    }
    function remAttr(dom, name) {
        dom.removeAttribute(name);
    }
    function toCamel(string) {
        return string.replace(/-(\w)/g, function(_, c) {
            return c.toUpperCase();
        });
    }
    function getAttr(dom, name) {
        return dom.getAttribute(name);
    }
    function setAttr(dom, name, val) {
        var xlink = XLINK_REGEX.exec(name);
        xlink && xlink[1] ? dom.setAttributeNS(XLINK_NS, xlink[1], val) : dom.setAttribute(name, val);
    }
    function getTag(dom) {
        return dom.tagName && __tagImpl[getAttr(dom, RIOT_TAG_IS) || getAttr(dom, RIOT_TAG) || dom.tagName.toLowerCase()];
    }
    function addChildTag(tag, tagName, parent) {
        var cachedTag = parent.tags[tagName];
        cachedTag ? (isArray(cachedTag) || cachedTag !== tag && (parent.tags[tagName] = [ cachedTag ]), 
        contains(parent.tags[tagName], tag) || parent.tags[tagName].push(tag)) : parent.tags[tagName] = tag;
    }
    function moveChildTag(tag, tagName, newPos) {
        var tags, parent = tag.parent;
        parent && (tags = parent.tags[tagName], isArray(tags) ? tags.splice(newPos, 0, tags.splice(tags.indexOf(tag), 1)[0]) : addChildTag(tag, tagName, parent));
    }
    function initChildTag(child, opts, innerHTML, parent) {
        var tag = new Tag(child, opts, innerHTML), tagName = getTagName(opts.root), ptag = getImmediateCustomParentTag(parent);
        return tag.parent = ptag, tag._parent = parent, addChildTag(tag, tagName, ptag), 
        ptag !== parent && addChildTag(tag, tagName, parent), opts.root.innerHTML = "", 
        tag;
    }
    function getImmediateCustomParentTag(tag) {
        for (var ptag = tag; !getTag(ptag.root) && ptag.parent; ) ptag = ptag.parent;
        return ptag;
    }
    function defineProperty(el, key, value, options) {
        return Object.defineProperty(el, key, extend({
            value: value,
            enumerable: !1,
            writable: !1,
            configurable: !0
        }, options)), el;
    }
    function getTagName(dom) {
        var child = getTag(dom), namedTag = getAttr(dom, "name"), tagName = namedTag && !tmpl.hasExpr(namedTag) ? namedTag : child ? child.name : dom.tagName.toLowerCase();
        return tagName;
    }
    function extend(src) {
        for (var obj, args = arguments, i = 1; i < args.length; ++i) if (obj = args[i]) for (var key in obj) isWritable(src, key) && (src[key] = obj[key]);
        return src;
    }
    function contains(arr, item) {
        return ~arr.indexOf(item);
    }
    function isArray(a) {
        return Array.isArray(a) || a instanceof Array;
    }
    function isWritable(obj, key) {
        var props = Object.getOwnPropertyDescriptor(obj, key);
        return typeof obj[key] === T_UNDEF || props && props.writable;
    }
    function cleanUpData(data) {
        if (!(data instanceof Tag || data && typeof data.trigger == T_FUNCTION)) return data;
        var o = {};
        for (var key in data) RESERVED_WORDS_BLACKLIST.test(key) || (o[key] = data[key]);
        return o;
    }
    function walk(dom, fn) {
        if (dom) {
            if (fn(dom) === !1) return;
            for (dom = dom.firstChild; dom; ) walk(dom, fn), dom = dom.nextSibling;
        }
    }
    function walkAttributes(html, fn) {
        for (var m, re = /([-\w]+) ?= ?(?:"([^"]*)|'([^']*)|({[^}]*}))/g; m = re.exec(html); ) fn(m[1].toLowerCase(), m[2] || m[3] || m[4]);
    }
    function isInStub(dom) {
        for (;dom; ) {
            if (dom.inStub) return !0;
            dom = dom.parentNode;
        }
        return !1;
    }
    function mkEl(name, isSvg) {
        return isSvg ? document.createElementNS("http://www.w3.org/2000/svg", "svg") : document.createElement(name);
    }
    function $$(selector, ctx) {
        return (ctx || document).querySelectorAll(selector);
    }
    function $(selector, ctx) {
        return (ctx || document).querySelector(selector);
    }
    function inherit(parent) {
        return Object.create(parent || null);
    }
    function getNamedKey(dom) {
        return getAttr(dom, "id") || getAttr(dom, "name");
    }
    function setNamed(dom, parent, keys) {
        var isArr, key = getNamedKey(dom), add = function(value) {
            contains(keys, key) || (isArr = isArray(value), value ? (!isArr || isArr && !contains(value, dom)) && (isArr ? value.push(dom) : parent[key] = [ value, dom ]) : parent[key] = dom);
        };
        key && (tmpl.hasExpr(key) ? parent.one("mount", function() {
            key = getNamedKey(dom), add(parent[key]);
        }) : add(parent[key]));
    }
    function startsWith(src, str) {
        return src.slice(0, str.length) === str;
    }
    function mountTo(root, tagName, opts) {
        var tag = __tagImpl[tagName], innerHTML = root._innerHTML = root._innerHTML || root.innerHTML;
        return root.innerHTML = "", tag && root && (tag = new Tag(tag, {
            root: root,
            opts: opts
        }, innerHTML)), tag && tag.mount && (tag.mount(), contains(__virtualDom, tag) || __virtualDom.push(tag)), 
        tag;
    }
    var riot = {
        version: "v2.6.7custom",
        settings: {}
    }, __uid = 0, __virtualDom = [], __tagImpl = {}, GLOBAL_MIXIN = "__global_mixin", RIOT_PREFIX = "riot-", RIOT_TAG = RIOT_PREFIX + "tag", RIOT_TAG_IS = "data-is", T_STRING = "string", T_OBJECT = "object", T_UNDEF = "undefined", T_FUNCTION = "function", XLINK_NS = "http://www.w3.org/1999/xlink", XLINK_REGEX = /^xlink:(\w+)/, SPECIAL_TAGS_REGEX = /^(?:t(?:body|head|foot|[rhd])|caption|col(?:group)?|opt(?:ion|group))$/, RESERVED_WORDS_BLACKLIST = /^(?:_(?:item|id|parent)|update|root|(?:un)?mount|mixin|is(?:Mounted|Loop)|tags|parent|opts|trigger|o(?:n|ff|ne))$/, SVG_TAGS_LIST = [ "altGlyph", "animate", "animateColor", "circle", "clipPath", "defs", "ellipse", "feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feFlood", "feGaussianBlur", "feImage", "feMerge", "feMorphology", "feOffset", "feSpecularLighting", "feTile", "feTurbulence", "filter", "font", "foreignObject", "g", "glyph", "glyphRef", "image", "line", "linearGradient", "marker", "mask", "missing-glyph", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "stop", "svg", "switch", "symbol", "text", "textPath", "tref", "tspan", "use" ], IE_VERSION = 0 | (window && window.document || {}).documentMode, FIREFOX = window && !!window.InstallTrigger;
    riot.observable = function(el) {
        function onEachEvent(e, fn) {
            for (var es = e.split(" "), l = es.length, i = 0; i < l; i++) {
                var name = es[i];
                name && fn(name, i);
            }
        }
        el = el || {};
        var callbacks = {}, slice = Array.prototype.slice;
        return Object.defineProperties(el, {
            on: {
                value: function(events, fn) {
                    return "function" != typeof fn ? el : (onEachEvent(events, function(name, pos) {
                        (callbacks[name] = callbacks[name] || []).push(fn), fn.typed = pos > 0;
                    }), el);
                },
                enumerable: !1,
                writable: !1,
                configurable: !1
            },
            off: {
                value: function(events, fn) {
                    return "*" != events || fn ? onEachEvent(events, function(name, pos) {
                        if (fn) for (var cb, arr = callbacks[name], i = 0; cb = arr && arr[i]; ++i) cb == fn && arr.splice(i--, 1); else delete callbacks[name];
                    }) : callbacks = {}, el;
                },
                enumerable: !1,
                writable: !1,
                configurable: !1
            },
            one: {
                value: function(events, fn) {
                    function on() {
                        el.off(events, on), fn.apply(el, arguments);
                    }
                    return el.on(events, on);
                },
                enumerable: !1,
                writable: !1,
                configurable: !1
            },
            trigger: {
                value: function(events) {
                    for (var fns, arglen = arguments.length - 1, args = new Array(arglen), i = 0; i < arglen; i++) args[i] = arguments[i + 1];
                    return onEachEvent(events, function(name, pos) {
                        fns = slice.call(callbacks[name] || [], 0);
                        for (var fn, i = 0; fn = fns[i]; ++i) fn.busy || (fn.busy = 1, fn.apply(el, fn.typed ? [ name ].concat(args) : args), 
                        fns[i] !== fn && i--, fn.busy = 0);
                        callbacks["*"] && "*" != name && el.trigger.apply(el, [ "*", name ].concat(args));
                    }), el;
                },
                enumerable: !1,
                writable: !1,
                configurable: !1
            }
        }), el;
    }, function(riot) {
        function DEFAULT_PARSER(path) {
            return path.split(/[\/?#]/);
        }
        function DEFAULT_SECOND_PARSER(path, filter) {
            var re = new RegExp("^" + filter[REPLACE](/\*/g, "([^/?#]+?)")[REPLACE](/\.\./, ".*") + "$"), args = path.match(re);
            if (args) return args.slice(1);
        }
        function debounce(fn, delay) {
            var t;
            return function() {
                clearTimeout(t), t = setTimeout(fn, delay);
            };
        }
        function start(autoExec) {
            debouncedEmit = debounce(emit, 1), win[ADD_EVENT_LISTENER](POPSTATE, debouncedEmit), 
            win[ADD_EVENT_LISTENER](HASHCHANGE, debouncedEmit), doc[ADD_EVENT_LISTENER](clickEvent, click), 
            autoExec && emit(!0);
        }
        function Router() {
            this.$ = [], riot.observable(this), central.on("stop", this.s.bind(this)), central.on("emit", this.e.bind(this));
        }
        function normalize(path) {
            return path[REPLACE](/^\/|\/$/, "");
        }
        function isString(str) {
            return "string" == typeof str;
        }
        function getPathFromRoot(href) {
            return (href || loc.href)[REPLACE](RE_ORIGIN, "");
        }
        function getPathFromBase(href) {
            return "#" == base[0] ? (href || loc.href || "").split(base)[1] || "" : (loc ? getPathFromRoot(href) : href || "")[REPLACE](base, "");
        }
        function emit(force) {
            var first, isRoot = 0 == emitStackLevel;
            if (!(MAX_EMIT_STACK_LEVEL <= emitStackLevel) && (emitStackLevel++, emitStack.push(function() {
                var path = getPathFromBase();
                (force || path != current) && (central[TRIGGER]("emit", path), current = path);
            }), isRoot)) {
                for (;first = emitStack.shift(); ) first();
                emitStackLevel = 0;
            }
        }
        function click(e) {
            if (!(1 != e.which || e.metaKey || e.ctrlKey || e.shiftKey || e.defaultPrevented)) {
                for (var el = e.target; el && "A" != el.nodeName; ) el = el.parentNode;
                !el || "A" != el.nodeName || el[HAS_ATTRIBUTE]("download") || !el[HAS_ATTRIBUTE]("href") || el.target && "_self" != el.target || el.href.indexOf(loc.href.match(RE_ORIGIN)[0]) == -1 || el.href != loc.href && (el.href.split("#")[0] == loc.href.split("#")[0] || "#" != base[0] && 0 !== getPathFromRoot(el.href).indexOf(base) || "#" == base[0] && el.href.split(base)[0] != loc.href.split(base)[0] || !go(getPathFromBase(el.href), el.title || doc.title)) || e.preventDefault();
            }
        }
        function go(path, title, shouldReplace) {
            return hist ? (path = base + normalize(path), title = title || doc.title, shouldReplace ? hist.replaceState(null, title, path) : hist.pushState(null, title, path), 
            doc.title = title, routeFound = !1, emit(), routeFound) : central[TRIGGER]("emit", getPathFromBase(path));
        }
        var debouncedEmit, base, current, parser, secondParser, RE_ORIGIN = /^.+?\/\/+[^\/]+/, EVENT_LISTENER = "EventListener", REMOVE_EVENT_LISTENER = "remove" + EVENT_LISTENER, ADD_EVENT_LISTENER = "add" + EVENT_LISTENER, HAS_ATTRIBUTE = "hasAttribute", REPLACE = "replace", POPSTATE = "popstate", HASHCHANGE = "hashchange", TRIGGER = "trigger", MAX_EMIT_STACK_LEVEL = 3, win = "undefined" != typeof window && window, doc = "undefined" != typeof document && document, hist = win && history, loc = win && (hist.location || win.location), prot = Router.prototype, clickEvent = doc && doc.ontouchstart ? "touchstart" : "click", started = !1, central = riot.observable(), routeFound = !1, emitStack = [], emitStackLevel = 0;
        prot.m = function(first, second, third) {
            !isString(first) || second && !isString(second) ? second ? this.r(first, second) : this.r("@", first) : go(first, second, third || !1);
        }, prot.s = function() {
            this.off("*"), this.$ = [];
        }, prot.e = function(path) {
            this.$.concat("@").some(function(filter) {
                var args = ("@" == filter ? parser : secondParser)(normalize(path), normalize(filter));
                if ("undefined" != typeof args) return this[TRIGGER].apply(null, [ filter ].concat(args)), 
                routeFound = !0;
            }, this);
        }, prot.r = function(filter, action) {
            "@" != filter && (filter = "/" + normalize(filter), this.$.push(filter)), this.on(filter, action);
        };
        var mainRouter = new Router(), route = mainRouter.m.bind(mainRouter);
        route.create = function() {
            var newSubRouter = new Router(), router = newSubRouter.m.bind(newSubRouter);
            return router.stop = newSubRouter.s.bind(newSubRouter), router;
        }, route.base = function(arg) {
            base = arg || "#", current = getPathFromBase();
        }, route.exec = function() {
            emit(!0);
        }, route.parser = function(fn, fn2) {
            fn || fn2 || (parser = DEFAULT_PARSER, secondParser = DEFAULT_SECOND_PARSER), fn && (parser = fn), 
            fn2 && (secondParser = fn2);
        }, route.query = function() {
            var q = {}, href = loc.href || current;
            return href[REPLACE](/[?&](.+?)=([^&]*)/g, function(_, k, v) {
                q[k] = v;
            }), q;
        }, route.stop = function() {
            started && (win && (win[REMOVE_EVENT_LISTENER](POPSTATE, debouncedEmit), win[REMOVE_EVENT_LISTENER](HASHCHANGE, debouncedEmit), 
            doc[REMOVE_EVENT_LISTENER](clickEvent, click)), central[TRIGGER]("stop"), started = !1);
        }, route.start = function(autoExec) {
            started || (win && ("complete" == document.readyState ? start(autoExec) : win[ADD_EVENT_LISTENER]("load", function() {
                setTimeout(function() {
                    start(autoExec);
                }, 1);
            })), started = !0);
        }, route.base(), route.parser(), riot.route = route;
    }(riot);
    var brackets = function(UNDEF) {
        function _loopback(re) {
            return re;
        }
        function _rewrite(re, bp) {
            return bp || (bp = _cache), new RegExp(re.source.replace(/{/g, bp[2]).replace(/}/g, bp[3]), re.global ? REGLOB : "");
        }
        function _create(pair) {
            if (pair === DEFAULT) return _pairs;
            var arr = pair.split(" ");
            if (2 !== arr.length || UNSUPPORTED.test(pair)) throw new Error('Unsupported brackets "' + pair + '"');
            return arr = arr.concat(pair.replace(NEED_ESCAPE, "\\").split(" ")), arr[4] = _rewrite(arr[1].length > 1 ? /{[\S\s]*?}/ : _pairs[4], arr), 
            arr[5] = _rewrite(pair.length > 3 ? /\\({|})/g : _pairs[5], arr), arr[6] = _rewrite(_pairs[6], arr), 
            arr[7] = RegExp("\\\\(" + arr[3] + ")|([[({])|(" + arr[3] + ")|" + S_QBLOCKS, REGLOB), 
            arr[8] = pair, arr;
        }
        function _brackets(reOrIdx) {
            return reOrIdx instanceof RegExp ? _regex(reOrIdx) : _cache[reOrIdx];
        }
        function _reset(pair) {
            (pair || (pair = DEFAULT)) !== _cache[8] && (_cache = _create(pair), _regex = pair === DEFAULT ? _loopback : _rewrite, 
            _cache[9] = _regex(_pairs[9])), cachedBrackets = pair;
        }
        function _setSettings(o) {
            var b;
            o = o || {}, b = o.brackets, Object.defineProperty(o, "brackets", {
                set: _reset,
                get: function() {
                    return cachedBrackets;
                },
                enumerable: !0
            }), _settings = o, _reset(b);
        }
        var _regex, _settings, REGLOB = "g", R_MLCOMMS = /\/\*[^*]*\*+(?:[^*\/][^*]*\*+)*\//g, R_STRINGS = /"[^"\\]*(?:\\[\S\s][^"\\]*)*"|'[^'\\]*(?:\\[\S\s][^'\\]*)*'/g, S_QBLOCKS = R_STRINGS.source + "|" + /(?:\breturn\s+|(?:[$\w\)\]]|\+\+|--)\s*(\/)(?![*\/]))/.source + "|" + /\/(?=[^*\/])[^[\/\\]*(?:(?:\[(?:\\.|[^\]\\]*)*\]|\\.)[^[\/\\]*)*?(\/)[gim]*/.source, UNSUPPORTED = RegExp("[\\x00-\\x1F<>a-zA-Z0-9'\",;\\\\]"), NEED_ESCAPE = /(?=[[\]()*+?.^$|])/g, FINDBRACES = {
            "(": RegExp("([()])|" + S_QBLOCKS, REGLOB),
            "[": RegExp("([[\\]])|" + S_QBLOCKS, REGLOB),
            "{": RegExp("([{}])|" + S_QBLOCKS, REGLOB)
        }, DEFAULT = "{ }", _pairs = [ "{", "}", "{", "}", /{[^}]*}/, /\\([{}])/g, /\\({)|{/g, RegExp("\\\\(})|([[({])|(})|" + S_QBLOCKS, REGLOB), DEFAULT, /^\s*{\^?\s*([$\w]+)(?:\s*,\s*(\S+))?\s+in\s+(\S.*)\s*}/, /(^|[^\\]){=[\S\s]*?}/ ], cachedBrackets = UNDEF, _cache = [];
        return _brackets.split = function(str, tmpl, _bp) {
            function unescapeStr(s) {
                tmpl || isexpr ? parts.push(s && s.replace(_bp[5], "$1")) : parts.push(s);
            }
            function skipBraces(s, ch, ix) {
                var match, recch = FINDBRACES[ch];
                for (recch.lastIndex = ix, ix = 1; (match = recch.exec(s)) && (!match[1] || (match[1] === ch ? ++ix : --ix)); ) ;
                return ix ? s.length : recch.lastIndex;
            }
            _bp || (_bp = _cache);
            var match, isexpr, start, pos, parts = [], re = _bp[6];
            for (isexpr = start = re.lastIndex = 0; match = re.exec(str); ) {
                if (pos = match.index, isexpr) {
                    if (match[2]) {
                        re.lastIndex = skipBraces(str, match[2], re.lastIndex);
                        continue;
                    }
                    if (!match[3]) continue;
                }
                match[1] || (unescapeStr(str.slice(start, pos)), start = re.lastIndex, re = _bp[6 + (isexpr ^= 1)], 
                re.lastIndex = start);
            }
            return str && start < str.length && unescapeStr(str.slice(start)), parts;
        }, _brackets.hasExpr = function(str) {
            return _cache[4].test(str);
        }, _brackets.loopKeys = function(expr) {
            var m = expr.match(_cache[9]);
            return m ? {
                key: m[1],
                pos: m[2],
                val: _cache[0] + m[3].trim() + _cache[1]
            } : {
                val: expr.trim()
            };
        }, _brackets.array = function(pair) {
            return pair ? _create(pair) : _cache;
        }, Object.defineProperty(_brackets, "settings", {
            set: _setSettings,
            get: function() {
                return _settings;
            }
        }), _brackets.settings = "undefined" != typeof riot && riot.settings || {}, _brackets.set = _reset, 
        _brackets.R_STRINGS = R_STRINGS, _brackets.R_MLCOMMS = R_MLCOMMS, _brackets.S_QBLOCKS = S_QBLOCKS, 
        _brackets;
    }(), tmpl = function() {
        function _tmpl(str, data) {
            return str ? (_cache[str] || (_cache[str] = _create(str))).call(data, _logErr) : str;
        }
        function _logErr(err, ctx) {
            _tmpl.errorHandler && (err.riotData = {
                tagName: ctx && ctx.root && ctx.root.tagName,
                _riot_id: ctx && ctx._riot_id
            }, _tmpl.errorHandler(err));
        }
        function _create(str) {
            var expr = _getTmpl(str);
            return "try{return " !== expr.slice(0, 11) && (expr = "return " + expr), new Function("E", expr + ";");
        }
        function _getTmpl(str) {
            var expr, qstr = [], parts = brackets.split(str.replace(RE_DQUOTE, '"'), 1);
            if (parts.length > 2 || parts[0]) {
                var i, j, list = [];
                for (i = j = 0; i < parts.length; ++i) expr = parts[i], expr && (expr = 1 & i ? _parseExpr(expr, 1, qstr) : '"' + expr.replace(/\\/g, "\\\\").replace(/\r\n?|\n/g, "\\n").replace(/"/g, '\\"') + '"') && (list[j++] = expr);
                expr = j < 2 ? list[0] : "[" + list.join(",") + '].join("")';
            } else expr = _parseExpr(parts[1], 0, qstr);
            return qstr[0] && (expr = expr.replace(RE_QBMARK, function(_, pos) {
                return qstr[pos].replace(/\r/g, "\\r").replace(/\n/g, "\\n");
            })), expr;
        }
        function _parseExpr(expr, asText, qstr) {
            function skipBraces(ch, re) {
                var mm, lv = 1, ir = RE_BREND[ch];
                for (ir.lastIndex = re.lastIndex; mm = ir.exec(expr); ) if (mm[0] === ch) ++lv; else if (!--lv) break;
                re.lastIndex = lv ? expr.length : ir.lastIndex;
            }
            if (expr = expr.replace(RE_QBLOCK, function(s, div) {
                return s.length > 2 && !div ? CH_IDEXPR + (qstr.push(s) - 1) + "~" : s;
            }).replace(/\s+/g, " ").trim().replace(/\ ?([[\({},?\.:])\ ?/g, "$1")) {
                for (var match, list = [], cnt = 0; expr && (match = expr.match(RE_CSNAME)) && !match.index; ) {
                    var key, jsb, re = /,|([[{(])|$/g;
                    for (expr = RegExp.rightContext, key = match[2] ? qstr[match[2]].slice(1, -1).trim().replace(/\s+/g, " ") : match[1]; jsb = (match = re.exec(expr))[1]; ) skipBraces(jsb, re);
                    jsb = expr.slice(0, match.index), expr = RegExp.rightContext, list[cnt++] = _wrapExpr(jsb, 1, key);
                }
                expr = cnt ? cnt > 1 ? "[" + list.join(",") + '].join(" ").trim()' : list[0] : _wrapExpr(expr, asText);
            }
            return expr;
        }
        function _wrapExpr(expr, asText, key) {
            var tb;
            return expr = expr.replace(JS_VARNAME, function(match, p, mvar, pos, s) {
                return mvar && (pos = tb ? 0 : pos + match.length, "this" !== mvar && "global" !== mvar && "window" !== mvar ? (match = p + '("' + mvar + JS_CONTEXT + mvar, 
                pos && (tb = "." === (s = s[pos]) || "(" === s || "[" === s)) : pos && (tb = !JS_NOPROPS.test(s.slice(pos)))), 
                match;
            }), tb && (expr = "try{return " + expr + "}catch(e){E(e,this)}"), key ? expr = (tb ? "function(){" + expr + "}.call(this)" : "(" + expr + ")") + '?"' + key + '":""' : asText && (expr = "function(v){" + (tb ? expr.replace("return ", "v=") : "v=(" + expr + ")") + ';return v||v===0?v:""}.call(this)'), 
            expr;
        }
        var _cache = {};
        _tmpl.haveRaw = brackets.hasRaw, _tmpl.hasExpr = brackets.hasExpr, _tmpl.loopKeys = brackets.loopKeys, 
        _tmpl.clearCache = function() {
            _cache = {};
        }, _tmpl.errorHandler = null;
        var CH_IDEXPR = String.fromCharCode(8279), RE_CSNAME = /^(?:(-?[_A-Za-z\xA0-\xFF][-\w\xA0-\xFF]*)|\u2057(\d+)~):/, RE_QBLOCK = RegExp(brackets.S_QBLOCKS, "g"), RE_DQUOTE = /\u2057/g, RE_QBMARK = /\u2057(\d+)~/g, RE_BREND = {
            "(": /[()]/g,
            "[": /[[\]]/g,
            "{": /[{}]/g
        }, JS_CONTEXT = '"in this?this:' + ("object" != typeof window ? "global" : "window") + ").", JS_VARNAME = /[,{][\$\w]+(?=:)|(^ *|[^$\w\.{])(?!(?:typeof|true|false|null|undefined|in|instanceof|is(?:Finite|NaN)|void|NaN|new|Date|RegExp|Math)(?![$\w]))([$_A-Za-z][$\w]*)/g, JS_NOPROPS = /^(?=(\.[$\w]+))\1(?:[^.[(]|$)/;
        return _tmpl.version = brackets.version = "v2.4.2", _tmpl;
    }(), mkdom = function _mkdom() {
        function _mkdom(templ, html, checkSvg) {
            var key = html ? templ + ":yield:" + html : templ, cachedItem = templateCache[key];
            if (!cachedItem) {
                var match = templ && templ.match(/^\s*<([-\w]+)/), tagName = match && match[1].toLowerCase(), el = mkEl("div", checkSvg && isSVGTag(tagName));
                templ = replaceYield(templ, html), tblTags.test(tagName) ? el = specialTags(el, templ, tagName) : setInnerHTML(el, templ), 
                cachedItem = el, templateCache[key] = cachedItem;
            }
            return el = cachedItem.cloneNode(!0), el.stub = !0, el;
        }
        function specialTags(el, templ, tagName) {
            var select = "o" === tagName[0], parent = select ? "select>" : "table>";
            if (el.innerHTML = "<" + parent + templ.trim() + "</" + parent, parent = el.firstChild, 
            select) parent.selectedIndex = -1; else {
                var tname = rootEls[tagName];
                tname && 1 === parent.childElementCount && (parent = $(tname, parent));
            }
            return parent;
        }
        function replaceYield(templ, html) {
            if (!reHasYield.test(templ)) return templ;
            var src = {};
            return html = html && html.replace(reYieldSrc, function(_, ref, text) {
                return src[ref] = src[ref] || text, "";
            }).trim(), templ.replace(reYieldDest, function(_, ref, def) {
                return src[ref] || def || "";
            }).replace(reYieldAll, function(_, def) {
                return html || def || "";
            });
        }
        var reHasYield = /<yield\b/i, reYieldAll = /<yield\s*(?:\/>|>([\S\s]*?)<\/yield\s*>|>)/gi, reYieldSrc = /<yield\s+to=['"]([^'">]*)['"]\s*>([\S\s]*?)<\/yield\s*>/gi, reYieldDest = /<yield\s+from=['"]?([-\w]+)['"]?\s*(?:\/>|>([\S\s]*?)<\/yield\s*>)/gi, rootEls = {
            tr: "tbody",
            th: "tr",
            td: "tr",
            col: "colgroup"
        }, tblTags = IE_VERSION && IE_VERSION < 10 ? SPECIAL_TAGS_REGEX : /^(?:t(?:body|head|foot|[rhd])|caption|col(?:group)?)$/, templateCache = {};
        return _mkdom;
    }(), styleManager = function(_riot) {
        if (!window) return {
            add: function() {},
            inject: function() {}
        };
        var styleNode = function() {
            var newNode = mkEl("style");
            setAttr(newNode, "type", "text/css");
            var userNode = $("style[type=riot]");
            return userNode ? (userNode.id && (newNode.id = userNode.id), userNode.parentNode.replaceChild(newNode, userNode)) : document.getElementsByTagName("head")[0].appendChild(newNode), 
            newNode;
        }(), cssTextProp = styleNode.styleSheet, stylesToInject = "";
        return Object.defineProperty(_riot, "styleNode", {
            value: styleNode,
            writable: !0
        }), {
            add: function(css) {
                stylesToInject += css;
            },
            inject: function() {
                stylesToInject && (cssTextProp ? cssTextProp.cssText += stylesToInject : styleNode.innerHTML += stylesToInject, 
                stylesToInject = "");
            }
        };
    }(riot), rAF = function(w) {
        var raf = w.requestAnimationFrame || w.mozRequestAnimationFrame || w.webkitRequestAnimationFrame;
        if (!raf || /iP(ad|hone|od).*OS 6/.test(w.navigator.userAgent)) {
            var lastTime = 0;
            raf = function(cb) {
                var nowtime = Date.now(), timeout = Math.max(16 - (nowtime - lastTime), 0);
                setTimeout(function() {
                    cb(lastTime = nowtime + timeout);
                }, timeout);
            };
        }
        return raf;
    }(window || {});
    riot.util = {
        brackets: brackets,
        tmpl: tmpl
    }, riot.mixin = function() {
        var mixins = {}, globals = mixins[GLOBAL_MIXIN] = {}, _id = 0;
        return function(name, mixin, g) {
            if (isObject(name)) return void riot.mixin("__unnamed_" + _id++, name, !0);
            var store = g ? globals : mixins;
            if (!mixin) {
                if (typeof store[name] === T_UNDEF) throw new Error("Unregistered mixin: " + name);
                return store[name];
            }
            isFunction(mixin) ? (extend(mixin.prototype, store[name] || {}), store[name] = mixin) : store[name] = extend(store[name] || {}, mixin);
        };
    }(), riot.tag = function(name, html, css, attrs, fn) {
        return isFunction(attrs) && (fn = attrs, /^[\w\-]+\s?=/.test(css) ? (attrs = css, 
        css = "") : attrs = ""), css && (isFunction(css) ? fn = css : styleManager.add(css)), 
        name = name.toLowerCase(), __tagImpl[name] = {
            name: name,
            tmpl: html,
            attrs: attrs,
            fn: fn
        }, name;
    }, riot.tag2 = function(name, html, css, attrs, fn) {
        return css && styleManager.add(css), __tagImpl[name] = {
            name: name,
            tmpl: html,
            attrs: attrs,
            fn: fn
        }, name;
    }, riot.mount = function(selector, tagName, opts) {
        function addRiotTags(arr) {
            var list = "";
            return each(arr, function(e) {
                /[^-\w]/.test(e) || (e = e.trim().toLowerCase(), list += ",[" + RIOT_TAG_IS + '="' + e + '"],[' + RIOT_TAG + '="' + e + '"]');
            }), list;
        }
        function selectAllTags() {
            var keys = Object.keys(__tagImpl);
            return keys + addRiotTags(keys);
        }
        function pushTags(root) {
            if (root.tagName) {
                var riotTag = getAttr(root, RIOT_TAG_IS) || getAttr(root, RIOT_TAG);
                tagName && riotTag !== tagName && (riotTag = tagName, setAttr(root, RIOT_TAG_IS, tagName), 
                setAttr(root, RIOT_TAG, tagName));
                var tag = mountTo(root, riotTag || root.tagName.toLowerCase(), opts);
                tag && tags.push(tag);
            } else root.length && each(root, pushTags);
        }
        var els, allTags, tags = [];
        if (styleManager.inject(), isObject(tagName) && (opts = tagName, tagName = 0), typeof selector === T_STRING ? ("*" === selector ? selector = allTags = selectAllTags() : selector += addRiotTags(selector.split(/, */)), 
        els = selector ? $$(selector) : []) : els = selector, "*" === tagName) {
            if (tagName = allTags || selectAllTags(), els.tagName) els = $$(tagName, els); else {
                var nodeList = [];
                each(els, function(_el) {
                    nodeList.push($$(tagName, _el));
                }), els = nodeList;
            }
            tagName = 0;
        }
        return pushTags(els), tags;
    }, riot.update = function() {
        return each(__virtualDom, function(tag) {
            tag.update();
        });
    }, riot.vdom = __virtualDom, riot.Tag = Tag, typeof exports === T_OBJECT ? module.exports = riot : typeof define === T_FUNCTION && typeof define.amd !== T_UNDEF ? define(function() {
        return riot;
    }) : window.riot = riot;
}("undefined" != typeof window ? window : void 0), function(w) {
    var routes = [], map = {}, reference = "routie", oldReference = w[reference], Route = function(path, name) {
        this.name = name, this.path = path, this.keys = [], this.fns = [], this.params = {}, 
        this.regex = pathToRegexp(this.path, this.keys, !1, !1);
    };
    Route.prototype.addHandler = function(fn) {
        this.fns.push(fn);
    }, Route.prototype.removeHandler = function(fn) {
        for (var i = 0, c = this.fns.length; i < c; i++) {
            var f = this.fns[i];
            if (fn == f) return void this.fns.splice(i, 1);
        }
    }, Route.prototype.run = function(params) {
        for (var i = 0, c = this.fns.length; i < c; i++) this.fns[i].apply(this, params);
    }, Route.prototype.match = function(path, params) {
        var m = this.regex.exec(path);
        if (!m) return !1;
        for (var i = 1, len = m.length; i < len; ++i) {
            var key = this.keys[i - 1], val = "string" == typeof m[i] ? decodeURIComponent(m[i]) : m[i];
            key && (this.params[key.name] = val), params.push(val);
        }
        return !0;
    }, Route.prototype.toURL = function(params) {
        var path = this.path;
        for (var param in params) path = path.replace("/:" + param, "/" + params[param]);
        if (path = path.replace(/\/:.*\?/g, "/").replace(/\?/g, ""), path.indexOf(":") != -1) throw new Error("missing parameters for url: " + path);
        return path;
    };
    var pathToRegexp = function(path, keys, sensitive, strict) {
        return path instanceof RegExp ? path : (path instanceof Array && (path = "(" + path.join("|") + ")"), 
        path = path.concat(strict ? "" : "/?").replace(/\/\(/g, "(?:/").replace(/\+/g, "__plus__").replace(/(\/)?(\.)?:(\w+)(?:(\(.*?\)))?(\?)?/g, function(_, slash, format, key, capture, optional) {
            return keys.push({
                name: key,
                optional: !!optional
            }), slash = slash || "", "" + (optional ? "" : slash) + "(?:" + (optional ? slash : "") + (format || "") + (capture || format && "([^/.]+?)" || "([^/]+?)") + ")" + (optional || "");
        }).replace(/([\/.])/g, "\\$1").replace(/__plus__/g, "(.+)").replace(/\*/g, "(.*)"), 
        new RegExp("^" + path + "$", sensitive ? "" : "i"));
    }, addHandler = function(path, fn) {
        var s = path.split(" "), name = 2 == s.length ? s[0] : null;
        path = 2 == s.length ? s[1] : s[0], map[path] || (map[path] = new Route(path, name), 
        routes.push(map[path])), map[path].addHandler(fn);
    }, routie = function(path, fn) {
        if ("function" == typeof fn) addHandler(path, fn), routie.reload(); else if ("object" == typeof path) {
            for (var p in path) addHandler(p, path[p]);
            routie.reload();
        } else "undefined" == typeof fn && routie.navigate(path);
    };
    routie.lookup = function(name, obj) {
        for (var i = 0, c = routes.length; i < c; i++) {
            var route = routes[i];
            if (route.name == name) return route.toURL(obj);
        }
    }, routie.remove = function(path, fn) {
        var route = map[path];
        route && route.removeHandler(fn);
    }, routie.removeAll = function() {
        map = {}, routes = [];
    }, routie.navigate = function(path, options) {
        options = options || {};
        var silent = options.silent || !1;
        silent && removeListener(), setTimeout(function() {
            window.location.hash = path, silent && setTimeout(function() {
                addListener();
            }, 1);
        }, 1);
    }, routie.noConflict = function() {
        return w[reference] = oldReference, routie;
    };
    var getHash = function() {
        return window.location.hash.substring(1);
    }, checkRoute = function(hash, route) {
        var params = [];
        return !!route.match(hash, params) && (route.run(params), !0);
    }, hashChanged = routie.reload = function() {
        for (var hash = getHash(), i = 0, c = routes.length; i < c; i++) {
            var route = routes[i];
            if (checkRoute(hash, route)) return;
        }
    }, addListener = function() {
        w.addEventListener ? w.addEventListener("hashchange", hashChanged, !1) : w.attachEvent("onhashchange", hashChanged);
    }, removeListener = function() {
        w.removeEventListener ? w.removeEventListener("hashchange", hashChanged) : w.detachEvent("onhashchange", hashChanged);
    };
    addListener(), w[reference] = routie;
}(window), !function(t) {
    if ("object" == typeof exports && "undefined" != typeof module) module.exports = t(); else if ("function" == typeof define && define.amd) define([], t); else {
        var e;
        e = "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this, 
        e.Baobab = t();
    }
}(function() {
    var t;
    return function e(t, r, n) {
        function o(a, s) {
            if (!r[a]) {
                if (!t[a]) {
                    var u = "function" == typeof require && require;
                    if (!s && u) return u(a, !0);
                    if (i) return i(a, !0);
                    var h = new Error("Cannot find module '" + a + "'");
                    throw h.code = "MODULE_NOT_FOUND", h;
                }
                var l = r[a] = {
                    exports: {}
                };
                t[a][0].call(l.exports, function(e) {
                    var r = t[a][1][e];
                    return o(r ? r : e);
                }, l, l.exports, e, t, r, n);
            }
            return r[a].exports;
        }
        for (var i = "function" == typeof require && require, a = 0; a < n.length; a++) o(n[a]);
        return o;
    }({
        1: [ function(e, r, n) {
            (function() {
                "use strict";
                function e(t, e) {
                    var r, n = {};
                    for (r in t) n[r] = t[r];
                    for (r in e) n[r] = e[r];
                    return n;
                }
                function o(t) {
                    return t && "object" == typeof t && !Array.isArray(t) && !(t instanceof Function) && !(t instanceof RegExp);
                }
                function i(t, e, r) {
                    var n, o, i, a;
                    for (o in t) e.call(r || null, o, t[o]);
                    if (Object.getOwnPropertySymbols) for (n = Object.getOwnPropertySymbols(t), i = 0, 
                    a = n.length; a > i; i++) e.call(r || null, n[i], t[n[i]]);
                }
                function a(t, e) {
                    t = t || [];
                    var r, n, o = [];
                    for (n = 0, r = t.length; r > n; n++) t[n].fn !== e && o.push(t[n]);
                    return o;
                }
                var s = {
                    once: "boolean",
                    scope: "object"
                }, u = 0, h = function() {
                    this._enabled = !0, this.unbindAll();
                };
                h.prototype.unbindAll = function() {
                    return this._handlers = {}, this._handlersAll = [], this._handlersComplex = [], 
                    this;
                }, h.prototype.on = function(t, e, r) {
                    var n, a, h, l, f, c, p;
                    if (o(t)) return i(t, function(t, r) {
                        this.on(t, r, e);
                    }, this), this;
                    for ("function" == typeof t && (r = e, e = t, t = null), f = [].concat(t), n = 0, 
                    a = f.length; a > n; n++) {
                        if (l = f[n], p = {
                            order: u++,
                            fn: e
                        }, "string" == typeof l || "symbol" == typeof l) this._handlers[l] || (this._handlers[l] = []), 
                        c = this._handlers[l], p.type = l; else if (l instanceof RegExp) c = this._handlersComplex, 
                        p.pattern = l; else {
                            if (null !== l) throw Error("Emitter.on: invalid event.");
                            c = this._handlersAll;
                        }
                        for (h in r || {}) s[h] && (p[h] = r[h]);
                        c.push(p);
                    }
                    return this;
                }, h.prototype.once = function() {
                    var t = Array.prototype.slice.call(arguments), r = t.length - 1;
                    return o(t[r]) && t.length > 1 ? t[r] = e(t[r], {
                        once: !0
                    }) : t.push({
                        once: !0
                    }), this.on.apply(this, t);
                }, h.prototype.off = function(t, e) {
                    var r, n, s, u;
                    if (1 === arguments.length && "function" == typeof t) {
                        e = arguments[0];
                        for (s in this._handlers) this._handlers[s] = a(this._handlers[s], e), 0 === this._handlers[s].length && delete this._handlers[s];
                        this._handlersAll = a(this._handlersAll, e), this._handlersComplex = a(this._handlersComplex, e);
                    } else if (1 !== arguments.length || "string" != typeof t && "symbol" != typeof t) if (2 === arguments.length) {
                        var h = [].concat(t);
                        for (r = 0, n = h.length; n > r; r++) u = h[r], this._handlers[u] = a(this._handlers[u], e), 
                        0 === (this._handlers[u] || []).length && delete this._handlers[u];
                    } else o(t) && i(t, this.off, this); else delete this._handlers[t];
                    return this;
                }, h.prototype.listeners = function(t) {
                    var e, r, n, o = this._handlersAll || [], i = !1;
                    if (!t) throw Error("Emitter.listeners: no event provided.");
                    for (o = o.concat(this._handlers[t] || []), r = 0, n = this._handlersComplex.length; n > r; r++) e = this._handlersComplex[r], 
                    ~t.search(e.pattern) && (i = !0, o.push(e));
                    return this._handlersAll.length || i ? o.sort(function(t, e) {
                        return t.order - e.order;
                    }) : o.slice(0);
                }, h.prototype.emit = function(t, e) {
                    if (!this._enabled) return this;
                    if (o(t)) return i(t, this.emit, this), this;
                    var r, n, a, s, u, h, l, f, c = [].concat(t), p = [];
                    for (u = 0, l = c.length; l > u; u++) {
                        for (a = this.listeners(c[u]), h = 0, f = a.length; f > h; h++) s = a[h], r = {
                            type: c[u],
                            target: this
                        }, arguments.length > 1 && (r.data = e), s.fn.call("scope" in s ? s.scope : this, r), 
                        s.once && p.push(s);
                        for (h = p.length - 1; h >= 0; h--) n = p[h].type ? this._handlers[p[h].type] : p[h].pattern ? this._handlersComplex : this._handlersAll, 
                        n.splice(n.indexOf(p[h]), 1);
                    }
                    return this;
                }, h.prototype.kill = function() {
                    this.unbindAll(), this._handlers = null, this._handlersAll = null, this._handlersComplex = null, 
                    this._enabled = !1, this.unbindAll = this.on = this.once = this.off = this.emit = this.listeners = Function.prototype;
                }, h.prototype.disable = function() {
                    return this._enabled = !1, this;
                }, h.prototype.enable = function() {
                    return this._enabled = !0, this;
                }, h.version = "3.1.1", "undefined" != typeof n ? ("undefined" != typeof r && r.exports && (n = r.exports = h), 
                n.Emitter = h) : "function" == typeof t && t.amd ? t("emmett", [], function() {
                    return h;
                }) : this.Emitter = h;
            }).call(this);
        }, {} ],
        2: [ function(t, e, r) {
            "use strict";
            function n(t) {
                if (t && t.__esModule) return t;
                var e = {};
                if (null != t) for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
                return e["default"] = t, e;
            }
            function o(t) {
                return t && t.__esModule ? t : {
                    "default": t
                };
            }
            function i(t, e) {
                if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
            }
            function a(t, e) {
                if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
            }
            function s(t) {
                return "λ" + t.map(function(t) {
                    return v["default"]["function"](t) || v["default"].object(t) ? "#" + B() + "#" : t;
                }).join("λ");
            }
            r.__esModule = !0;
            var u = t("emmett"), h = o(u), l = t("./cursor"), f = o(l), c = t("./monkey"), p = t("./watcher"), d = o(p), y = t("./type"), v = o(y), m = t("./update"), g = o(m), b = t("./helpers"), _ = n(b), w = _.arrayFrom, k = _.coercePath, P = _.deepFreeze, j = _.getIn, M = _.makeError, C = _.deepClone, O = _.deepMerge, E = _.shallowClone, x = _.shallowMerge, B = _.uniqid, D = {
                autoCommit: !0,
                asynchronous: !0,
                immutable: !0,
                lazyMonkeys: !0,
                persistent: !0,
                pure: !0,
                validate: null,
                validationBehavior: "rollback"
            }, z = function(t) {
                function e(r, n) {
                    var o = this;
                    if (i(this, e), t.call(this), arguments.length < 1 && (r = {}), !v["default"].object(r) && !v["default"].array(r)) throw M("Baobab: invalid data.", {
                        data: r
                    });
                    this.options = x({}, D, n), this.options.persistent || (this.options.immutable = !1, 
                    this.options.pure = !1), this._identity = "[object Baobab]", this._cursors = {}, 
                    this._future = null, this._transaction = [], this._affectedPathsIndex = {}, this._monkeys = {}, 
                    this._previousData = null, this._data = r, this.root = new f["default"](this, [], "λ"), 
                    delete this.root.release, this.options.immutable && P(this._data);
                    var a = function(t) {
                        o[t] = function() {
                            var e = this.root[t].apply(this.root, arguments);
                            return e instanceof f["default"] ? this : e;
                        };
                    };
                    [ "apply", "clone", "concat", "deepClone", "deepMerge", "exists", "get", "push", "merge", "pop", "project", "serialize", "set", "shift", "splice", "unset", "unshift" ].forEach(a), 
                    this._refreshMonkeys();
                    var s = this.validate();
                    if (s) throw Error("Baobab: invalid data.", {
                        error: s
                    });
                }
                return a(e, t), e.prototype._refreshMonkeys = function(t, e, r) {
                    var n = this, o = function s(t) {
                        var e = arguments.length <= 1 || void 0 === arguments[1] ? [] : arguments[1];
                        if (t instanceof c.Monkey) return t.release(), void g["default"](n._monkeys, e, {
                            type: "unset"
                        }, {
                            immutable: !1,
                            persistent: !1,
                            pure: !1
                        });
                        if (v["default"].object(t)) for (var r in t) s(t[r], e.concat(r));
                    }, i = function u(t) {
                        var e = arguments.length <= 1 || void 0 === arguments[1] ? [] : arguments[1];
                        if (t instanceof c.MonkeyDefinition || t instanceof c.Monkey) {
                            var r = new c.Monkey(n, e, t instanceof c.Monkey ? t.definition : t);
                            return void g["default"](n._monkeys, e, {
                                type: "set",
                                value: r
                            }, {
                                immutable: !1,
                                persistent: !1,
                                pure: !1
                            });
                        }
                        if (v["default"].object(t)) for (var o in t) u(t[o], e.concat(o));
                    };
                    if (arguments.length) {
                        var a = j(this._monkeys, e).data;
                        a && o(a, e), "unset" !== r && i(t, e);
                    } else i(this._data);
                    return this;
                }, e.prototype.validate = function r(t) {
                    var e = this.options, r = e.validate, n = e.validationBehavior;
                    if ("function" != typeof r) return null;
                    var o = r.call(this, this._previousData, this._data, t || [ [] ]);
                    return o instanceof Error ? ("rollback" === n && (this._data = this._previousData, 
                    this._affectedPathsIndex = {}, this._transaction = [], this._previousData = this._data), 
                    this.emit("invalid", {
                        error: o
                    }), o) : null;
                }, e.prototype.select = function(t) {
                    if (t = t || [], arguments.length > 1 && (t = w(arguments)), !v["default"].path(t)) throw M("Baobab.select: invalid path.", {
                        path: t
                    });
                    t = [].concat(t);
                    var e = s(t), r = this._cursors[e];
                    return r || (r = new f["default"](this, t, e), this._cursors[e] = r), this.emit("select", {
                        path: t,
                        cursor: r
                    }), r;
                }, e.prototype.update = function(t, e) {
                    var r = this;
                    if (t = k(t), !v["default"].operationType(e.type)) throw M('Baobab.update: unknown operation type "' + e.type + '".', {
                        operation: e
                    });
                    var n = j(this._data, t), o = n.solvedPath, i = n.exists;
                    if (!o) throw M("Baobab.update: could not solve the given path.", {
                        path: o
                    });
                    var a = v["default"].monkeyPath(this._monkeys, o);
                    if (a && o.length > a.length) throw M("Baobab.update: attempting to update a read-only path.", {
                        path: o
                    });
                    if ("unset" !== e.type || i) {
                        var u = e;
                        if (/merge/i.test(e.type)) {
                            var h = j(this._monkeys, o).data;
                            if (v["default"].object(h)) {
                                u = E(u);
                                var l = j(this._data, o).data;
                                /deep/i.test(u.type) ? u.value = O({}, O({}, l, C(h)), u.value) : u.value = x({}, O({}, l, C(h)), u.value);
                            }
                        }
                        this._transaction.length || (this._previousData = this._data);
                        var f = g["default"](this._data, o, u, this.options), c = f.data, p = f.node;
                        if (!("data" in f)) return p;
                        var d = o.concat("push" === e.type ? p.length - 1 : []), y = s(d);
                        return this._data = c, this._affectedPathsIndex[y] = !0, this._transaction.push(x({}, e, {
                            path: d
                        })), this._refreshMonkeys(p, o, e.type), this.emit("write", {
                            path: d
                        }), this.options.autoCommit ? this.options.asynchronous ? (this._future || (this._future = setTimeout(function() {
                            return r.commit();
                        }, 0)), p) : (this.commit(), p) : p;
                    }
                }, e.prototype.commit = function() {
                    if (!this._transaction.length) return this;
                    this._future && (this._future = clearTimeout(this._future));
                    var t = Object.keys(this._affectedPathsIndex).map(function(t) {
                        return "λ" !== t ? t.split("λ").slice(1) : [];
                    }), e = this.validate(t);
                    if (e) return this;
                    var r = this._transaction, n = this._previousData;
                    return this._affectedPathsIndex = {}, this._transaction = [], this._previousData = this._data, 
                    this.emit("update", {
                        paths: t,
                        currentData: this._data,
                        transaction: r,
                        previousData: n
                    }), this;
                }, e.prototype.getMonkey = function(t) {
                    t = k(t);
                    var e = j(this._monkeys, [].concat(t)).data;
                    return e instanceof c.Monkey ? e : null;
                }, e.prototype.watch = function(t) {
                    return new d["default"](this, t);
                }, e.prototype.release = function() {
                    var t = void 0;
                    this.emit("release"), delete this.root, delete this._data, delete this._previousData, 
                    delete this._transaction, delete this._affectedPathsIndex, delete this._monkeys;
                    for (t in this._cursors) this._cursors[t].release();
                    delete this._cursors, this.kill();
                }, e.prototype.toJSON = function() {
                    return this.serialize();
                }, e.prototype.toString = function() {
                    return this._identity;
                }, e;
            }(h["default"]);
            r["default"] = z, z.monkey = function() {
                for (var t = arguments.length, e = Array(t), r = 0; t > r; r++) e[r] = arguments[r];
                if (!e.length) throw new Error("Baobab.monkey: missing definition.");
                return 1 === e.length && "function" != typeof e[0] ? new c.MonkeyDefinition(e[0]) : new c.MonkeyDefinition(e);
            }, z.dynamicNode = z.monkey, z.Cursor = f["default"], z.MonkeyDefinition = c.MonkeyDefinition, 
            z.Monkey = c.Monkey, z.type = v["default"], z.helpers = _, z.VERSION = "2.3.2", 
            e.exports = r["default"];
        }, {
            "./cursor": 3,
            "./helpers": 4,
            "./monkey": 5,
            "./type": 6,
            "./update": 7,
            "./watcher": 8,
            emmett: 1
        } ],
        3: [ function(t, e, r) {
            "use strict";
            function n(t) {
                return t && t.__esModule ? t : {
                    "default": t
                };
            }
            function o(t, e) {
                if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
            }
            function i(t, e) {
                if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
            }
            function a(t, e) {
                if (!e) throw p.makeError("Baobab.Cursor." + t + ": " + ("cannot use " + t + " on an unresolved dynamic path."), {
                    path: e
                });
            }
            function s(t, e) {
                d.prototype[t] = function(r, n) {
                    if (arguments.length > 2) throw p.makeError("Baobab.Cursor." + t + ": too many arguments.");
                    if (1 !== arguments.length || y[t] || (n = r, r = []), r = p.coercePath(r), !c["default"].path(r)) throw p.makeError("Baobab.Cursor." + t + ": invalid path.", {
                        path: r
                    });
                    if (e && !e(n)) throw p.makeError("Baobab.Cursor." + t + ": invalid value.", {
                        path: r,
                        value: n
                    });
                    if (!this.solvedPath) throw p.makeError("Baobab.Cursor." + t + ": the dynamic path of the cursor cannot be solved.", {
                        path: this.path
                    });
                    var o = this.solvedPath.concat(r);
                    return this.tree.update(o, {
                        type: t,
                        value: n
                    });
                };
            }
            r.__esModule = !0;
            var u = t("emmett"), h = n(u), l = t("./monkey"), f = t("./type"), c = n(f), p = t("./helpers"), d = function(t) {
                function e(r, n, i) {
                    var a = this;
                    o(this, e), t.call(this), n = n || [], this._identity = "[object Cursor]", this._archive = null, 
                    this.tree = r, this.path = n, this.hash = i, this.state = {
                        killed: !1,
                        recording: !1,
                        undoing: !1
                    }, this._dynamicPath = c["default"].dynamicPath(this.path), this._monkeyPath = c["default"].monkeyPath(this.tree._monkeys, this.path), 
                    this._dynamicPath ? this.solvedPath = p.getIn(this.tree._data, this.path).solvedPath : this.solvedPath = this.path, 
                    this._writeHandler = function(t) {
                        var e = t.data;
                        !a.state.killed && p.solveUpdate([ e.path ], a._getComparedPaths()) && (a.solvedPath = p.getIn(a.tree._data, a.path).solvedPath);
                    };
                    var s = function(t) {
                        var e = a, r = Object.defineProperties({}, {
                            previousData: {
                                get: function() {
                                    return p.getIn(t, e.solvedPath).data;
                                },
                                configurable: !0,
                                enumerable: !0
                            },
                            currentData: {
                                get: function() {
                                    return e.get();
                                },
                                configurable: !0,
                                enumerable: !0
                            }
                        });
                        return a.state.recording && !a.state.undoing && a.archive.add(r.previousData), a.state.undoing = !1, 
                        a.emit("update", r);
                    };
                    this._updateHandler = function(t) {
                        if (!a.state.killed) {
                            var e = t.data, r = e.paths, n = e.previousData, o = s.bind(a, n), i = a._getComparedPaths();
                            return p.solveUpdate(r, i) ? o() : void 0;
                        }
                    };
                    var u = !1;
                    this._lazyBind = function() {
                        return u ? void 0 : (u = !0, a._dynamicPath && a.tree.on("write", a._writeHandler), 
                        a.tree.on("update", a._updateHandler));
                    }, this._dynamicPath ? this._lazyBind() : (this.on = p.before(this._lazyBind, this.on.bind(this)), 
                    this.once = p.before(this._lazyBind, this.once.bind(this)));
                }
                return i(e, t), e.prototype._getComparedPaths = function() {
                    var t = this._monkeyPath ? p.getIn(this.tree._monkeys, this._monkeyPath).data.relatedPaths() : [];
                    return [ this.solvedPath ].concat(t);
                }, e.prototype.isRoot = function() {
                    return !this.path.length;
                }, e.prototype.isLeaf = function() {
                    return c["default"].primitive(this._get().data);
                }, e.prototype.isBranch = function() {
                    return !this.isRoot() && !this.isLeaf();
                }, e.prototype.root = function() {
                    return this.tree.select();
                }, e.prototype.select = function(t) {
                    return arguments.length > 1 && (t = p.arrayFrom(arguments)), this.tree.select(this.path.concat(t));
                }, e.prototype.up = function() {
                    return this.isRoot() ? null : this.tree.select(this.path.slice(0, -1));
                }, e.prototype.down = function() {
                    if (a("down", this.solvedPath), !(this._get().data instanceof Array)) throw Error("Baobab.Cursor.down: cannot go down on a non-list type.");
                    return this.tree.select(this.solvedPath.concat(0));
                }, e.prototype.left = function() {
                    a("left", this.solvedPath);
                    var t = +this.solvedPath[this.solvedPath.length - 1];
                    if (isNaN(t)) throw Error("Baobab.Cursor.left: cannot go left on a non-list type.");
                    return t ? this.tree.select(this.solvedPath.slice(0, -1).concat(t - 1)) : null;
                }, e.prototype.right = function() {
                    a("right", this.solvedPath);
                    var t = +this.solvedPath[this.solvedPath.length - 1];
                    if (isNaN(t)) throw Error("Baobab.Cursor.right: cannot go right on a non-list type.");
                    return t + 1 === this.up()._get().data.length ? null : this.tree.select(this.solvedPath.slice(0, -1).concat(t + 1));
                }, e.prototype.leftmost = function() {
                    a("leftmost", this.solvedPath);
                    var t = +this.solvedPath[this.solvedPath.length - 1];
                    if (isNaN(t)) throw Error("Baobab.Cursor.leftmost: cannot go left on a non-list type.");
                    return this.tree.select(this.solvedPath.slice(0, -1).concat(0));
                }, e.prototype.rightmost = function() {
                    a("rightmost", this.solvedPath);
                    var t = +this.solvedPath[this.solvedPath.length - 1];
                    if (isNaN(t)) throw Error("Baobab.Cursor.rightmost: cannot go right on a non-list type.");
                    var e = this.up()._get().data;
                    return this.tree.select(this.solvedPath.slice(0, -1).concat(e.length - 1));
                }, e.prototype.map = function(t, e) {
                    a("map", this.solvedPath);
                    var r = this._get().data, n = arguments.length;
                    if (!c["default"].array(r)) throw Error("baobab.Cursor.map: cannot map a non-list type.");
                    return r.map(function(o, i) {
                        return t.call(n > 1 ? e : this, this.select(i), i, r);
                    }, this);
                }, e.prototype._get = function() {
                    var t = arguments.length <= 0 || void 0 === arguments[0] ? [] : arguments[0];
                    if (!c["default"].path(t)) throw p.makeError("Baobab.Cursor.getters: invalid path.", {
                        path: t
                    });
                    return this.solvedPath ? p.getIn(this.tree._data, this.solvedPath.concat(t)) : {
                        data: void 0,
                        solvedPath: null,
                        exists: !1
                    };
                }, e.prototype.exists = function(t) {
                    return t = p.coercePath(t), arguments.length > 1 && (t = p.arrayFrom(arguments)), 
                    this._get(t).exists;
                }, e.prototype.get = function(t) {
                    t = p.coercePath(t), arguments.length > 1 && (t = p.arrayFrom(arguments));
                    var e = this._get(t), r = e.data, n = e.solvedPath;
                    return this.tree.emit("get", {
                        data: r,
                        solvedPath: n,
                        path: this.path.concat(t)
                    }), r;
                }, e.prototype.clone = function() {
                    var t = this.get.apply(this, arguments);
                    return p.shallowClone(t);
                }, e.prototype.deepClone = function() {
                    var t = this.get.apply(this, arguments);
                    return p.deepClone(t);
                }, e.prototype.serialize = function(t) {
                    if (t = p.coercePath(t), arguments.length > 1 && (t = p.arrayFrom(arguments)), !c["default"].path(t)) throw p.makeError("Baobab.Cursor.getters: invalid path.", {
                        path: t
                    });
                    if (this.solvedPath) {
                        var e = this.solvedPath.concat(t), r = p.deepClone(p.getIn(this.tree._data, e).data), n = p.getIn(this.tree._monkeys, e).data, o = function i(t, e) {
                            if (c["default"].object(e) && c["default"].object(t)) for (var r in e) e[r] instanceof l.Monkey ? delete t[r] : i(t[r], e[r]);
                        };
                        return o(r, n), r;
                    }
                }, e.prototype.project = function(t) {
                    if (c["default"].object(t)) {
                        var e = {};
                        for (var r in t) e[r] = this.get(t[r]);
                        return e;
                    }
                    if (c["default"].array(t)) {
                        for (var e = [], n = 0, o = t.length; o > n; n++) e.push(this.get(t[n]));
                        return e;
                    }
                    throw p.makeError("Baobab.Cursor.project: wrong projection.", {
                        projection: t
                    });
                }, e.prototype.startRecording = function(t) {
                    if (t = t || 1 / 0, 1 > t) throw p.makeError("Baobab.Cursor.startRecording: invalid max records.", {
                        value: t
                    });
                    return this.state.recording = !0, this.archive ? this : (this._lazyBind(), this.archive = new p.Archive(t), 
                    this);
                }, e.prototype.stopRecording = function() {
                    return this.state.recording = !1, this;
                }, e.prototype.undo = function() {
                    var t = arguments.length <= 0 || void 0 === arguments[0] ? 1 : arguments[0];
                    if (!this.state.recording) throw new Error("Baobab.Cursor.undo: cursor is not recording.");
                    var e = this.archive.back(t);
                    if (!e) throw Error("Baobab.Cursor.undo: cannot find a relevant record.");
                    return this.state.undoing = !0, this.set(e), this;
                }, e.prototype.hasHistory = function() {
                    return !(!this.archive || !this.archive.get().length);
                }, e.prototype.getHistory = function() {
                    return this.archive ? this.archive.get() : [];
                }, e.prototype.clearHistory = function() {
                    return this.archive && this.archive.clear(), this;
                }, e.prototype.release = function() {
                    this._dynamicPath && this.tree.off("write", this._writeHandler), this.tree.off("update", this._updateHandler), 
                    this.hash && delete this.tree._cursors[this.hash], delete this.tree, delete this.path, 
                    delete this.solvedPath, delete this.archive, this.kill(), this.state.killed = !0;
                }, e.prototype.toJSON = function() {
                    return this.serialize();
                }, e.prototype.toString = function() {
                    return this._identity;
                }, e;
            }(h["default"]);
            r["default"] = d, "function" == typeof Symbol && "undefined" != typeof Symbol.iterator && (d.prototype[Symbol.iterator] = function() {
                var t = this._get().data;
                if (!c["default"].array(t)) throw Error("baobab.Cursor.@@iterate: cannot iterate a non-list type.");
                var e = 0, r = this, n = t.length;
                return {
                    next: function() {
                        return n > e ? {
                            value: r.select(e++)
                        } : {
                            done: !0
                        };
                    }
                };
            });
            var y = {
                unset: !0,
                pop: !0,
                shift: !0
            };
            s("set"), s("unset"), s("apply", c["default"]["function"]), s("push"), s("concat", c["default"].array), 
            s("unshift"), s("pop"), s("shift"), s("splice", c["default"].splicer), s("merge", c["default"].object), 
            s("deepMerge", c["default"].object), e.exports = r["default"];
        }, {
            "./helpers": 4,
            "./monkey": 5,
            "./type": 6,
            emmett: 1
        } ],
        4: [ function(t, e, r) {
            (function(e) {
                "use strict";
                function n(t) {
                    return t && t.__esModule ? t : {
                        "default": t
                    };
                }
                function o(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
                }
                function i(t, e) {
                    var r = void 0, n = void 0;
                    for (r = 0, n = t.length; n > r; r++) if (e(t[r])) return r;
                    return -1;
                }
                function a(t) {
                    var e = new Array(t.length), r = void 0, n = void 0;
                    for (r = 0, n = t.length; n > r; r++) e[r] = t[r];
                    return e;
                }
                function s(t) {
                    return a(t);
                }
                function u(t, e) {
                    return function() {
                        t.apply(null, arguments), e.apply(null, arguments);
                    };
                }
                function h(t) {
                    var e = t.source, r = "";
                    return t.global && (r += "g"), t.multiline && (r += "m"), t.ignoreCase && (r += "i"), 
                    t.sticky && (r += "y"), t.unicode && (r += "u"), new RegExp(e, r);
                }
                function l(t, r) {
                    if (!r || "object" != typeof r || r instanceof Error || r instanceof _.MonkeyDefinition || r instanceof _.Monkey || "ArrayBuffer" in e && r instanceof ArrayBuffer) return r;
                    if (k["default"].array(r)) {
                        if (t) {
                            var n = [], o = void 0, i = void 0;
                            for (o = 0, i = r.length; i > o; o++) n.push(l(!0, r[o]));
                            return n;
                        }
                        return a(r);
                    }
                    if (r instanceof Date) return new Date(r.getTime());
                    if (r instanceof RegExp) return h(r);
                    if (k["default"].object(r)) {
                        var s = {}, u = void 0;
                        for (u in r) k["default"].lazyGetter(r, u) ? Object.defineProperty(s, u, {
                            get: Object.getOwnPropertyDescriptor(r, u).get,
                            enumerable: !0,
                            configurable: !0
                        }) : r.hasOwnProperty(u) && (s[u] = t ? l(!0, r[u]) : r[u]);
                        return s;
                    }
                    return r;
                }
                function f(t) {
                    return t || 0 === t || "" === t ? t : [];
                }
                function c(t, e) {
                    var r = !0, n = void 0;
                    if (!t) return !1;
                    for (n in e) if (k["default"].object(e[n])) r = r && c(t[n], e[n]); else if (k["default"].array(e[n])) r = r && !!~e[n].indexOf(t[n]); else if (t[n] !== e[n]) return !1;
                    return r;
                }
                function p(t, e) {
                    if (!("object" != typeof e || null === e || e instanceof _.Monkey) && (Object.freeze(e), 
                    t)) if (Array.isArray(e)) {
                        var r = void 0, n = void 0;
                        for (r = 0, n = e.length; n > r; r++) p(!0, e[r]);
                    } else {
                        var o = void 0, i = void 0;
                        for (i in e) k["default"].lazyGetter(e, i) || (o = e[i], o && e.hasOwnProperty(i) && "object" == typeof o && !Object.isFrozen(o) && p(!0, o));
                    }
                }
                function d(t, e) {
                    if (!e) return B;
                    var r = [], n = !0, o = t, a = void 0, s = void 0, u = void 0;
                    for (s = 0, u = e.length; u > s; s++) {
                        if (!o) return {
                            data: void 0,
                            solvedPath: r.concat(e.slice(s)),
                            exists: !1
                        };
                        if ("function" == typeof e[s]) {
                            if (!k["default"].array(o)) return B;
                            if (a = i(o, e[s]), !~a) return B;
                            r.push(a), o = o[a];
                        } else if ("object" == typeof e[s]) {
                            if (!k["default"].array(o)) return B;
                            if (a = i(o, function(t) {
                                return c(t, e[s]);
                            }), !~a) return B;
                            r.push(a), o = o[a];
                        } else r.push(e[s]), n = "object" == typeof o && e[s] in o, o = o[e[s]];
                    }
                    return {
                        data: o,
                        solvedPath: r,
                        exists: n
                    };
                }
                function y(t, e) {
                    var r = new Error(t);
                    for (var n in e) r[n] = e[n];
                    return r;
                }
                function v(t) {
                    for (var e = arguments.length, r = Array(e > 1 ? e - 1 : 0), n = 1; e > n; n++) r[n - 1] = arguments[n];
                    var o = r[0], i = void 0, a = void 0, s = void 0, u = void 0;
                    for (a = 1, s = r.length; s > a; a++) {
                        i = r[a];
                        for (u in i) !t || !k["default"].object(i[u]) || i[u] instanceof _.Monkey ? o[u] = i[u] : o[u] = v(!0, o[u] || {}, i[u]);
                    }
                    return o;
                }
                function m(t, e) {
                    var r = [];
                    e = [].concat(e);
                    for (var n = 0, o = e.length; o > n; n++) {
                        var i = e[n];
                        "." === i ? n || (r = t.slice(0)) : ".." === i ? r = (n ? r : t).slice(0, -1) : r.push(i);
                    }
                    return r;
                }
                function g(t, e) {
                    var r = void 0, n = void 0, o = void 0, i = void 0, a = void 0, s = void 0, u = void 0, h = void 0, l = void 0;
                    for (r = 0, i = t.length; i > r; r++) {
                        if (u = t[r], !u.length) return !0;
                        for (n = 0, a = e.length; a > n; n++) {
                            if (h = e[n], !h || !h.length) return !0;
                            for (o = 0, s = h.length; s > o && (l = h[o], l == u[o]); o++) if (o + 1 === s || o + 1 === u.length) return !0;
                        }
                    }
                    return !1;
                }
                function b(t, e, r) {
                    r = Math.max(0, r), k["default"]["function"](e) && (e = i(t, e)), k["default"].object(e) && (e = i(t, function(t) {
                        return c(t, e);
                    }));
                    for (var n = arguments.length, o = Array(n > 3 ? n - 3 : 0), a = 3; n > a; a++) o[a - 3] = arguments[a];
                    return e >= 0 ? t.slice(0, e).concat(o).concat(t.slice(e + r)) : t.slice(0, t.length + e).concat(o).concat(t.slice(t.length + e + r));
                }
                r.__esModule = !0, r.arrayFrom = s, r.before = u, r.coercePath = f, r.getIn = d, 
                r.makeError = y, r.solveRelativePath = m, r.solveUpdate = g, r.splice = b;
                var _ = t("./monkey"), w = t("./type"), k = n(w), P = Function.prototype, j = function() {
                    function t(e) {
                        o(this, t), this.size = e, this.records = [];
                    }
                    return t.prototype.get = function() {
                        return this.records;
                    }, t.prototype.add = function(t) {
                        return this.records.unshift(t), this.records.length > this.size && (this.records.length = this.size), 
                        this;
                    }, t.prototype.clear = function() {
                        return this.records = [], this;
                    }, t.prototype.back = function(t) {
                        var e = this.records[t - 1];
                        return e && (this.records = this.records.slice(t)), e;
                    }, t;
                }();
                r.Archive = j;
                var M = l.bind(null, !1), C = l.bind(null, !0);
                r.shallowClone = M, r.deepClone = C;
                var O = "function" == typeof Object.freeze, E = O ? p.bind(null, !1) : P, x = O ? p.bind(null, !0) : P;
                r.freeze = E, r.deepFreeze = x;
                var B = {
                    data: void 0,
                    solvedPath: null,
                    exists: !1
                }, D = v.bind(null, !1), z = v.bind(null, !0);
                r.shallowMerge = D, r.deepMerge = z;
                var A = function() {
                    var t = 0;
                    return function() {
                        return t++;
                    };
                }();
                r.uniqid = A;
            }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
        }, {
            "./monkey": 5,
            "./type": 6
        } ],
        5: [ function(t, e, r) {
            "use strict";
            function n(t) {
                return t && t.__esModule ? t : {
                    "default": t
                };
            }
            function o(t, e) {
                if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
            }
            r.__esModule = !0;
            var i = t("./type"), a = n(i), s = t("./update"), u = n(s), h = t("./helpers"), l = function c(t) {
                var e = this;
                o(this, c);
                var r = a["default"].monkeyDefinition(t);
                if (!r) throw h.makeError("Baobab.monkey: invalid definition.", {
                    definition: t
                });
                if (this.type = r, "object" === this.type) this.getter = t.get, this.projection = t.cursors || {}, 
                this.paths = Object.keys(this.projection).map(function(t) {
                    return e.projection[t];
                }), this.options = t.options || {}; else {
                    var n = 1, i = {};
                    a["default"].object(t[t.length - 1]) && (n++, i = t[t.length - 1]), this.getter = t[t.length - n], 
                    this.projection = t.slice(0, -n), this.paths = this.projection, this.options = i;
                }
                this.paths = this.paths.map(function(t) {
                    return [].concat(t);
                }), this.hasDynamicPaths = this.paths.some(a["default"].dynamicPath);
            };
            r.MonkeyDefinition = l;
            var f = function() {
                function t(e, r, n) {
                    var i = this;
                    o(this, t), this.tree = e, this.path = r, this.definition = n;
                    var a = n.projection, s = h.solveRelativePath.bind(null, r.slice(0, -1));
                    "object" === n.type ? (this.projection = Object.keys(a).reduce(function(t, e) {
                        return t[e] = s(a[e]), t;
                    }, {}), this.depPaths = Object.keys(this.projection).map(function(t) {
                        return i.projection[t];
                    })) : (this.projection = a.map(s), this.depPaths = this.projection), this.state = {
                        killed: !1
                    }, this.writeListener = function(t) {
                        var e = t.data.path;
                        if (!i.state.killed) {
                            var r = h.solveUpdate([ e ], i.relatedPaths());
                            r && i.update();
                        }
                    }, this.recursiveListener = function(t) {
                        var e = t.data, r = e.monkey, n = e.path;
                        if (!i.state.killed && i !== r) {
                            var o = h.solveUpdate([ n ], i.relatedPaths(!1));
                            o && i.update();
                        }
                    }, this.tree.on("write", this.writeListener), this.tree.on("_monkey", this.recursiveListener), 
                    this.update();
                }
                return t.prototype.relatedPaths = function() {
                    var t = this, e = arguments.length <= 0 || void 0 === arguments[0] || arguments[0], r = void 0;
                    r = this.definition.hasDynamicPaths ? this.depPaths.map(function(e) {
                        return h.getIn(t.tree._data, e).solvedPath;
                    }) : this.depPaths;
                    var n = e && this.depPaths.some(function(e) {
                        return !!a["default"].monkeyPath(t.tree._monkeys, e);
                    });
                    return n ? r.reduce(function(e, r) {
                        var n = a["default"].monkeyPath(t.tree._monkeys, r);
                        if (!n) return e.concat([ r ]);
                        var o = h.getIn(t.tree._monkeys, n).data;
                        return e.concat(o.relatedPaths());
                    }, []) : r;
                }, t.prototype.update = function() {
                    var t = this.tree.project(this.projection), e = function(t, e, r) {
                        var n = null, o = !1;
                        return function() {
                            return o || (n = e.getter.apply(t, "object" === e.type ? [ r ] : r), t.options.immutable && e.options.immutable !== !1 && h.deepFreeze(n), 
                            o = !0), n;
                        };
                    }(this.tree, this.definition, t);
                    if (e.isLazyGetter = !0, this.tree.options.lazyMonkeys) this.tree._data = u["default"](this.tree._data, this.path, {
                        type: "monkey",
                        value: e
                    }, this.tree.options).data; else {
                        var r = u["default"](this.tree._data, this.path, {
                            type: "set",
                            value: e(),
                            options: {
                                mutableLeaf: !this.definition.options.immutable
                            }
                        }, this.tree.options);
                        "data" in r && (this.tree._data = r.data);
                    }
                    return this.tree.emit("_monkey", {
                        monkey: this,
                        path: this.path
                    }), this;
                }, t.prototype.release = function() {
                    this.tree.off("write", this.writeListener), this.tree.off("_monkey", this.monkeyListener), 
                    this.state.killed = !0, delete this.projection, delete this.depPaths, delete this.tree;
                }, t;
            }();
            r.Monkey = f;
        }, {
            "./helpers": 4,
            "./type": 6,
            "./update": 7
        } ],
        6: [ function(t, e, r) {
            "use strict";
            function n(t, e) {
                return e.some(function(e) {
                    return i[e](t);
                });
            }
            r.__esModule = !0;
            var o = t("./monkey"), i = {};
            i.array = function(t) {
                return Array.isArray(t);
            }, i.object = function(t) {
                return t && "object" == typeof t && !Array.isArray(t) && !(t instanceof Date) && !(t instanceof RegExp) && !("function" == typeof Map && t instanceof Map) && !("function" == typeof Set && t instanceof Set);
            }, i.string = function(t) {
                return "string" == typeof t;
            }, i.number = function(t) {
                return "number" == typeof t;
            }, i["function"] = function(t) {
                return "function" == typeof t;
            }, i.primitive = function(t) {
                return t !== Object(t);
            }, i.splicer = function(t) {
                return !(!i.array(t) || t.length < 2) && (n(t[0], [ "number", "function", "object" ]) && i.number(t[1]));
            };
            var a = [ "string", "number", "function", "object" ];
            i.path = function(t) {
                return !(!t && 0 !== t && "" !== t) && [].concat(t).every(function(t) {
                    return n(t, a);
                });
            }, i.dynamicPath = function(t) {
                return t.some(function(t) {
                    return i["function"](t) || i.object(t);
                });
            }, i.monkeyPath = function(t, e) {
                var r = [], n = t, i = void 0, a = void 0;
                for (i = 0, a = e.length; a > i; i++) {
                    if (r.push(e[i]), "object" != typeof n) return null;
                    if (n = n[e[i]], n instanceof o.Monkey) return r;
                }
                return null;
            }, i.lazyGetter = function(t, e) {
                var r = Object.getOwnPropertyDescriptor(t, e);
                return r && r.get && r.get.isLazyGetter === !0;
            }, i.monkeyDefinition = function(t) {
                if (i.object(t)) return i["function"](t.get) && (!t.cursors || i.object(t.cursors) && Object.keys(t.cursors).every(function(e) {
                    return i.path(t.cursors[e]);
                })) ? "object" : null;
                if (i.array(t)) {
                    var e = 1;
                    return i.object(t[t.length - 1]) && e++, i["function"](t[t.length - e]) && t.slice(0, -e).every(function(t) {
                        return i.path(t);
                    }) ? "array" : null;
                }
                return null;
            }, i.watcherMapping = function(t) {
                return i.object(t) && Object.keys(t).every(function(e) {
                    return i.path(t[e]);
                });
            };
            var s = [ "set", "apply", "push", "unshift", "concat", "pop", "shift", "deepMerge", "merge", "splice", "unset" ];
            i.operationType = function(t) {
                return "string" == typeof t && !!~s.indexOf(t);
            }, r["default"] = i, e.exports = r["default"];
        }, {
            "./monkey": 5
        } ],
        7: [ function(t, e, r) {
            "use strict";
            function n(t) {
                return t && t.__esModule ? t : {
                    "default": t
                };
            }
            function o(t, e, r) {
                return u.makeError('Baobab.update: cannot apply the "' + t + '" on ' + ("a non " + e + " (path: /" + r.join("/") + ")."), {
                    path: r
                });
            }
            function i(t, e, r) {
                var n = arguments.length <= 3 || void 0 === arguments[3] ? {} : arguments[3], i = r.type, a = r.value, h = r.options, l = void 0 === h ? {} : h, f = {
                    root: t
                }, c = [ "root" ].concat(e), p = [], d = f, y = void 0, v = void 0, m = void 0;
                for (y = 0, v = c.length; v > y; y++) {
                    if (m = c[y], y > 0 && p.push(m), y === v - 1) {
                        if ("set" === i) {
                            if (n.pure && d[m] === a) return {
                                node: d[m]
                            };
                            s["default"].lazyGetter(d, m) ? Object.defineProperty(d, m, {
                                value: a,
                                enumerable: !0,
                                configurable: !0
                            }) : n.persistent && !l.mutableLeaf ? d[m] = u.shallowClone(a) : d[m] = a;
                        } else if ("monkey" === i) Object.defineProperty(d, m, {
                            get: a,
                            enumerable: !0,
                            configurable: !0
                        }); else if ("apply" === i) {
                            var g = a(d[m]);
                            if (n.pure && d[m] === g) return {
                                node: d[m]
                            };
                            s["default"].lazyGetter(d, m) ? Object.defineProperty(d, m, {
                                value: g,
                                enumerable: !0,
                                configurable: !0
                            }) : n.persistent ? d[m] = u.shallowClone(g) : d[m] = g;
                        } else if ("push" === i) {
                            if (!s["default"].array(d[m])) throw o("push", "array", p);
                            n.persistent ? d[m] = d[m].concat([ a ]) : d[m].push(a);
                        } else if ("unshift" === i) {
                            if (!s["default"].array(d[m])) throw o("unshift", "array", p);
                            n.persistent ? d[m] = [ a ].concat(d[m]) : d[m].unshift(a);
                        } else if ("concat" === i) {
                            if (!s["default"].array(d[m])) throw o("concat", "array", p);
                            n.persistent ? d[m] = d[m].concat(a) : d[m].push.apply(d[m], a);
                        } else if ("splice" === i) {
                            if (!s["default"].array(d[m])) throw o("splice", "array", p);
                            n.persistent ? d[m] = u.splice.apply(null, [ d[m] ].concat(a)) : d[m].splice.apply(d[m], a);
                        } else if ("pop" === i) {
                            if (!s["default"].array(d[m])) throw o("pop", "array", p);
                            n.persistent ? d[m] = u.splice(d[m], -1, 1) : d[m].pop();
                        } else if ("shift" === i) {
                            if (!s["default"].array(d[m])) throw o("shift", "array", p);
                            n.persistent ? d[m] = u.splice(d[m], 0, 1) : d[m].shift();
                        } else if ("unset" === i) s["default"].object(d) ? delete d[m] : s["default"].array(d) && d.splice(m, 1); else if ("merge" === i) {
                            if (!s["default"].object(d[m])) throw o("merge", "object", p);
                            n.persistent ? d[m] = u.shallowMerge({}, d[m], a) : d[m] = u.shallowMerge(d[m], a);
                        } else if ("deepMerge" === i) {
                            if (!s["default"].object(d[m])) throw o("deepMerge", "object", p);
                            n.persistent ? d[m] = u.deepMerge({}, d[m], a) : d[m] = u.deepMerge(d[m], a);
                        }
                        n.immutable && !l.mutableLeaf && u.deepFreeze(d);
                        break;
                    }
                    s["default"].primitive(d[m]) ? d[m] = {} : n.persistent && (d[m] = u.shallowClone(d[m])), 
                    n.immutable && v > 0 && u.freeze(d), d = d[m];
                }
                return s["default"].lazyGetter(d, m) ? {
                    data: f.root
                } : {
                    data: f.root,
                    node: d[m]
                };
            }
            r.__esModule = !0, r["default"] = i;
            var a = t("./type"), s = n(a), u = t("./helpers");
            e.exports = r["default"];
        }, {
            "./helpers": 4,
            "./type": 6
        } ],
        8: [ function(t, e, r) {
            "use strict";
            function n(t) {
                return t && t.__esModule ? t : {
                    "default": t
                };
            }
            function o(t, e) {
                if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
            }
            function i(t, e) {
                if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
            }
            r.__esModule = !0;
            var a = t("emmett"), s = n(a), u = t("./cursor"), h = n(u), l = t("./type"), f = n(l), c = t("./helpers"), p = function(t) {
                function e(r, n) {
                    var i = this;
                    o(this, e), t.call(this), this.tree = r, this.mapping = null, this.state = {
                        killed: !1
                    }, this.refresh(n), this.handler = function(t) {
                        if (!i.state.killed) {
                            var e = i.getWatchedPaths();
                            return c.solveUpdate(t.data.paths, e) ? i.emit("update") : void 0;
                        }
                    }, this.tree.on("update", this.handler);
                }
                return i(e, t), e.prototype.getWatchedPaths = function() {
                    var t = this, e = Object.keys(this.mapping).map(function(e) {
                        var r = t.mapping[e];
                        return r instanceof h["default"] ? r.solvedPath : t.mapping[e];
                    });
                    return e.reduce(function(e, r) {
                        if (r = [].concat(r), f["default"].dynamicPath(r) && (r = c.getIn(t.tree._data, r).solvedPath), 
                        !r) return e;
                        var n = f["default"].monkeyPath(t.tree._monkeys, r);
                        return n ? e.concat(c.getIn(t.tree._monkeys, n).data.relatedPaths()) : e.concat([ r ]);
                    }, []);
                }, e.prototype.getCursors = function() {
                    var t = this, e = {};
                    return Object.keys(this.mapping).forEach(function(r) {
                        var n = t.mapping[r];
                        n instanceof h["default"] ? e[r] = n : e[r] = t.tree.select(n);
                    }), e;
                }, e.prototype.refresh = function(t) {
                    if (!f["default"].watcherMapping(t)) throw c.makeError("Baobab.watch: invalid mapping.", {
                        mapping: t
                    });
                    this.mapping = t;
                    var e = {};
                    for (var r in t) e[r] = t[r] instanceof h["default"] ? t[r].path : t[r];
                    this.get = this.tree.project.bind(this.tree, e);
                }, e.prototype.release = function() {
                    this.tree.off("update", this.handler), this.state.killed = !0, this.kill();
                }, e;
            }(s["default"]);
            r["default"] = p, e.exports = r["default"];
        }, {
            "./cursor": 3,
            "./helpers": 4,
            "./type": 6,
            emmett: 1
        } ]
    }, {}, [ 2 ])(2);
}), window.componentHandler = function() {
    "use strict";
    function e(e, t) {
        for (var s = 0; s < h.length; s++) if (h[s].className === e) return void 0 !== t && (h[s] = t), 
        h[s];
        return !1;
    }
    function t(e) {
        var t = e.getAttribute("data-upgraded");
        return null === t ? [ "" ] : t.split(",");
    }
    function s(e, s) {
        var n = t(e);
        return -1 !== n.indexOf(s);
    }
    function n(t, s) {
        if (void 0 === t && void 0 === s) for (var o = 0; o < h.length; o++) n(h[o].className, h[o].cssClass); else {
            var l = t;
            if (void 0 === s) {
                var r = e(l);
                r && (s = r.cssClass);
            }
            for (var a = document.querySelectorAll("." + s), c = 0; c < a.length; c++) i(a[c], l);
        }
    }
    function i(n, i) {
        if (!("object" == typeof n && n instanceof Element)) throw new Error("Invalid argument provided to upgrade SPC element.");
        var o = t(n), l = [];
        if (i) s(n, i) || l.push(e(i)); else {
            var r = n.classList;
            h.forEach(function(e) {
                r.contains(e.cssClass) && -1 === l.indexOf(e) && !s(n, e.className) && l.push(e);
            });
        }
        for (var a, u = 0, d = l.length; d > u; u++) {
            if (a = l[u], !a) throw new Error("Unable to find a registered component for the given class.");
            o.push(a.className), n.setAttribute("data-upgraded", o.join(","));
            var _ = new a.classConstructor(n);
            _[p] = a, c.push(_);
            for (var C = 0, S = a.callbacks.length; S > C; C++) a.callbacks[C](n);
            a.widget && (n[a.className] = _);
            var m = document.createEvent("Events");
            m.initEvent("spc-componentupgraded", !0, !0), n.dispatchEvent(m);
        }
    }
    function o(e) {
        Array.isArray(e) || (e = "function" == typeof e.item ? Array.prototype.slice.call(e) : [ e ]);
        for (var t, s = 0, n = e.length; n > s; s++) t = e[s], t instanceof HTMLElement && (t.children.length > 0 && o(t.children), 
        i(t));
    }
    function l(t) {
        var s = {
            classConstructor: t.constructor,
            className: t.classAsString,
            cssClass: t.cssClass,
            widget: void 0 === t.widget || t.widget,
            callbacks: []
        };
        if (h.forEach(function(e) {
            if (e.cssClass === s.cssClass) throw new Error("The provided cssClass has already been registered.");
            if (e.className === s.className) throw new Error("The provided className has already been registered");
        }), t.constructor.prototype.hasOwnProperty(p)) throw new Error("SPC component classes must not have " + p + " defined as a property.");
        var n = e(t.classAsString, s);
        n || h.push(s);
    }
    function r(t, s) {
        var n = e(t);
        n && n.callbacks.push(s);
    }
    function a() {
        for (var e = 0; e < h.length; e++) n(h[e].className);
    }
    var h = [], c = [], p = "spcComponentConfigInternal_";
    return {
        upgradeElement: i,
        upgradeElements: o,
        upgradeAll: a,
        registerUpgradedCallback: r,
        register: l
    };
}(), window.addEventListener("load", function() {
    "classList" in document.createElement("div") && "querySelector" in document && "addEventListener" in window && Array.prototype.forEach ? (document.documentElement.classList.add("spc-js"), 
    componentHandler.upgradeAll()) : (componentHandler.upgradeElement = componentHandler.register = function() {}, 
    console.warn("[componentHandler] Unsupported browser"));
});

var SpectreCheckbox = function(e) {
    this.element_ = e, this.init();
};

SpectreCheckbox.prototype.CssClasses_ = {
    INPUT: "spc-checkbox__input",
    BOX_OUTLINE: "spc-checkbox__box-outline",
    TICK_OUTLINE: "spc-checkbox__tick-outline",
    IS_FOCUSED: "is-focused",
    IS_DISABLED: "is-disabled",
    IS_CHECKED: "is-checked",
    IS_UPGRADED: "is-upgraded"
}, SpectreCheckbox.prototype.onChange_ = function(e) {
    this.updateClasses_();
}, SpectreCheckbox.prototype.onFocus_ = function(e) {
    this.element_.classList.add(this.CssClasses_.IS_FOCUSED);
}, SpectreCheckbox.prototype.onBlur_ = function(e) {
    this.element_.classList.remove(this.CssClasses_.IS_FOCUSED);
}, SpectreCheckbox.prototype.onMouseUp_ = function(e) {
    this.blur_();
}, SpectreCheckbox.prototype.updateClasses_ = function() {
    this.checkDisabled(), this.checkToggleState();
}, SpectreCheckbox.prototype.blur_ = function(e) {
    window.setTimeout(function() {
        this.element_.classList.remove(this.CssClasses_.IS_FOCUSED);
    }.bind(this), 0);
}, SpectreCheckbox.prototype.checkToggleState = function() {
    this.inputElement_.checked ? this.element_.classList.add(this.CssClasses_.IS_CHECKED) : this.element_.classList.remove(this.CssClasses_.IS_CHECKED);
}, SpectreCheckbox.prototype.checkDisabled = function() {
    this.inputElement_.disabled ? this.element_.classList.add(this.CssClasses_.IS_DISABLED) : this.element_.classList.remove(this.CssClasses_.IS_DISABLED);
}, SpectreCheckbox.prototype.disable = function() {
    this.inputElement_.disabled = !0, this.updateClasses_();
}, SpectreCheckbox.prototype.enable = function() {
    this.inputElement_.disabled = !1, this.updateClasses_();
}, SpectreCheckbox.prototype.check = function() {
    this.inputElement_.checked = !0, this.updateClasses_();
}, SpectreCheckbox.prototype.uncheck = function() {
    this.inputElement_.checked = !1, this.updateClasses_();
}, SpectreCheckbox.prototype.init = function() {
    if (this.element_) {
        this.inputElement_ = this.element_.querySelector("." + this.CssClasses_.INPUT);
        var e = document.createElement("span");
        e.classList.add(this.CssClasses_.BOX_OUTLINE);
        var t = document.createElement("span");
        t.classList.add(this.CssClasses_.TICK_OUTLINE), e.appendChild(t), this.element_.appendChild(e), 
        this.boundInputOnChange = this.onChange_.bind(this), this.boundInputOnFocus = this.onFocus_.bind(this), 
        this.boundInputOnBlur = this.onBlur_.bind(this), this.boundElementMouseUp = this.onMouseUp_.bind(this), 
        this.inputElement_.addEventListener("change", this.boundInputOnChange), this.inputElement_.addEventListener("focus", this.boundInputOnFocus), 
        this.inputElement_.addEventListener("blur", this.boundInputOnBlur), this.element_.addEventListener("mouseup", this.boundElementMouseUp), 
        this.updateClasses_(), this.element_.classList.add(this.CssClasses_.IS_UPGRADED);
    }
}, componentHandler.register({
    constructor: SpectreCheckbox,
    classAsString: "SpectreCheckbox",
    cssClass: "spc-js-checkbox",
    widget: !0
});

var SpectreIconToggle = function(e) {
    this.element_ = e, this.init();
};

SpectreIconToggle.prototype.CssClasses_ = {
    INPUT: "spc-icon-toggle__input",
    IS_FOCUSED: "is-focused",
    IS_DISABLED: "is-disabled",
    IS_CHECKED: "is-checked"
}, SpectreIconToggle.prototype.onChange_ = function(e) {
    this.updateClasses_();
}, SpectreIconToggle.prototype.onFocus_ = function(e) {
    this.element_.classList.add(this.CssClasses_.IS_FOCUSED);
}, SpectreIconToggle.prototype.onBlur_ = function(e) {
    this.element_.classList.remove(this.CssClasses_.IS_FOCUSED);
}, SpectreIconToggle.prototype.onMouseUp_ = function(e) {
    this.blur_();
}, SpectreIconToggle.prototype.updateClasses_ = function() {
    this.checkDisabled(), this.checkToggleState();
}, SpectreIconToggle.prototype.blur_ = function(e) {
    window.setTimeout(function() {
        this.element_.classList.remove(this.CssClasses_.IS_FOCUSED);
    }.bind(this), 0);
}, SpectreIconToggle.prototype.checkToggleState = function() {
    this.inputElement_.checked ? this.element_.classList.add(this.CssClasses_.IS_CHECKED) : this.element_.classList.remove(this.CssClasses_.IS_CHECKED);
}, SpectreIconToggle.prototype.checkDisabled = function() {
    this.inputElement_.disabled ? this.element_.classList.add(this.CssClasses_.IS_DISABLED) : this.element_.classList.remove(this.CssClasses_.IS_DISABLED);
}, SpectreIconToggle.prototype.disable = function() {
    this.inputElement_.disabled = !0, this.updateClasses_();
}, SpectreIconToggle.prototype.enable = function() {
    this.inputElement_.disabled = !1, this.updateClasses_();
}, SpectreIconToggle.prototype.check = function() {
    this.inputElement_.checked = !0, this.updateClasses_();
}, SpectreIconToggle.prototype.uncheck = function() {
    this.inputElement_.checked = !1, this.updateClasses_();
}, SpectreIconToggle.prototype.init = function() {
    this.element_ && (this.inputElement_ = this.element_.querySelector("." + this.CssClasses_.INPUT), 
    this.boundInputOnChange = this.onChange_.bind(this), this.boundInputOnFocus = this.onFocus_.bind(this), 
    this.boundInputOnBlur = this.onBlur_.bind(this), this.boundElementOnMouseUp = this.onMouseUp_.bind(this), 
    this.inputElement_.addEventListener("change", this.boundInputOnChange), this.inputElement_.addEventListener("focus", this.boundInputOnFocus), 
    this.inputElement_.addEventListener("blur", this.boundInputOnBlur), this.element_.addEventListener("mouseup", this.boundElementOnMouseUp), 
    this.updateClasses_(), this.element_.classList.add("is-upgraded"));
}, SpectreIconToggle.prototype.spcDowngrade_ = function() {
    this.inputElement_.removeEventListener("change", this.boundInputOnChange), this.inputElement_.removeEventListener("focus", this.boundInputOnFocus), 
    this.inputElement_.removeEventListener("blur", this.boundInputOnBlur), this.element_.removeEventListener("mouseup", this.boundElementOnMouseUp);
}, componentHandler.register({
    constructor: SpectreIconToggle,
    classAsString: "SpectreIconToggle",
    cssClass: "spc-js-icon-toggle",
    widget: !0
});

var SpectreDropdown = function(e) {
    this.element_ = e, this.init();
};

SpectreDropdown.prototype.CssClasses_ = {
    IS_DISABLED: "is-disabled",
    IS_OPEN: "is-open",
    IS_CHECKED: "is-checked",
    IS_FOCUS: "is-focus",
    SELECTED: "spc-dropdown__selected",
    OPTION: "spc-dropdown__option",
    OPTIONS: "spc-dropdown__options"
}, SpectreDropdown.prototype.Keycodes_ = {
    ENTER: 13,
    TAB: 9,
    UP_ARROW: 38,
    DOWN_ARROW: 40,
    SPACE_BAR: 32,
    ESC: 27
}, SpectreDropdown.prototype.onClick_ = function(e) {
    if (!this.isDisabled() && !e.target.classList.contains(this.CssClasses_.OPTIONS)) {
        var t = this.findAncestor_(e.target, this.CssClasses_.OPTION);
        t && this.checkElement(t), this.toggleState();
    }
}, SpectreDropdown.prototype.isDisabled = function() {
    return this.element_.classList.contains(this.CssClasses_.IS_DISABLED);
}, SpectreDropdown.prototype.isOpen = function() {
    return this.element_.classList.contains(this.CssClasses_.IS_OPEN);
}, SpectreDropdown.prototype.toggleState = function() {
    this.element_.dispatchEvent(new Event("toggle", {
        bubbles: !0
    })), this.isOpen() ? this.element_.dispatchEvent(new Event("closed", {
        bubbles: !0
    })) : this.element_.dispatchEvent(new Event("opened", {
        bubbles: !0
    })), this.element_.classList.toggle(this.CssClasses_.IS_OPEN);
}, SpectreDropdown.prototype.checkElement = function(e) {
    if (e) {
        var t = this.element_.querySelector("." + this.CssClasses_.IS_CHECKED);
        t && t.classList.remove(this.CssClasses_.IS_CHECKED), e.classList.add(this.CssClasses_.IS_CHECKED), 
        e.dispatchEvent(new Event("change", {
            bubbles: !0
        })), e.dispatchEvent(new Event("checked", {
            bubbles: !0
        }));
    }
}, SpectreDropdown.prototype.focusElement = function(e) {
    var t = this.element_.querySelector("." + this.CssClasses_.IS_FOCUS);
    t && t.classList.remove(this.CssClasses_.IS_FOCUS), e.classList.add(this.CssClasses_.IS_FOCUS);
}, SpectreDropdown.prototype.init = function() {
    this.element_ && (this.currentIndex_ = -1, this.selectedElement_ = this.element_.querySelector("." + this.CssClasses_.SELECTED), 
    this.inputElements_ = this.element_.querySelectorAll("." + this.CssClasses_.OPTION), 
    this.boundInputOnChange = this.onChange_.bind(this), this.boundElementOnClick = this.onClick_.bind(this), 
    this.boundElementOnKeyDown = this.onKeyDown_.bind(this), this.boundElementOnBlur = this.onBlur_.bind(this), 
    this.boundElementOnFocus = this.onFocus_.bind(this), this.element_.addEventListener("click", this.boundElementOnClick), 
    this.element_.addEventListener("change", this.boundInputOnChange), this.element_.addEventListener("keydown", this.boundElementOnKeyDown), 
    this.element_.addEventListener("blur", this.boundElementOnBlur, !0), this.element_.addEventListener("focus", this.boundElementOnFocus, !0), 
    this.element_.classList.add("is-upgraded"), this.updateClasses_());
}, SpectreDropdown.prototype.onKeyDown_ = function(e) {
    0 === this.inputElements_.length || this.isDisabled() || (e.keyCode === this.Keycodes_.DOWN_ARROW ? (this.isOpen() ? this.currentIndex_++ : this.toggleState(), 
    this.currentIndex_ >= this.inputElements_.length && (this.currentIndex_ = 0), this.focusElement(this.inputElements_[this.currentIndex_]), 
    this.scrollTo_(this.inputElements_[this.currentIndex_].offsetTop, 250, this.element_.querySelector(".spc-dropdown__options")), 
    e.preventDefault(), e.stopPropagation()) : e.keyCode === this.Keycodes_.UP_ARROW ? (this.currentIndex_--, 
    this.currentIndex_ < 0 && (this.currentIndex_ = this.inputElements_.length - 1), 
    this.focusElement(this.inputElements_[this.currentIndex_]), this.scrollTo_(this.inputElements_[this.currentIndex_].offsetTop, 250, this.element_.querySelector(".spc-dropdown__options")), 
    e.preventDefault(), e.stopPropagation()) : e.keyCode === this.Keycodes_.ENTER ? this.isOpen() && (this.checkElement(this.inputElements_[this.currentIndex_]), 
    this.toggleState(), e.preventDefault(), e.stopPropagation()) : e.keyCode === this.Keycodes_.ESC ? this.isOpen() && (this.toggleState(), 
    e.preventDefault(), e.stopPropagation()) : e.keyCode === this.Keycodes_.SPACE_BAR && (this.isOpen() && this.checkElement(this.inputElements_[this.currentIndex_]), 
    this.isDisabled() || this.toggleState(), -1 === this.currentIndex_ && (this.currentIndex_ = 0), 
    this.focusElement(this.inputElements_[this.currentIndex_]), e.preventDefault(), 
    e.stopPropagation()));
}, SpectreDropdown.prototype.onChange_ = function(e) {
    this.updateClasses_();
}, SpectreDropdown.prototype.onBlur_ = function(e) {
    this.closeTimeout = setTimeout(function() {
        this.element_.classList.remove(this.CssClasses_.IS_OPEN);
    }.bind(this), 0);
}, SpectreDropdown.prototype.onFocus_ = function(e) {
    clearTimeout(this.closeTimeout);
}, SpectreDropdown.prototype.updateClasses_ = function() {
    this.inputElements_ = this.element_.querySelectorAll("." + this.CssClasses_.OPTION);
    var e, t;
    for (e = 0, t = this.inputElements_.length; t > e; e++) this.inputElements_[e].classList.contains(this.CssClasses_.IS_CHECKED) && (this.selectedElement_.innerHTML = this.inputElements_[e].innerHTML, 
    this.currentIndex_ = e);
    0 === this.inputElements_.length && this.element_.classList.add(this.CssClasses_.IS_DISABLED);
}, SpectreDropdown.prototype.easeInOutQuad_ = function(e, t, s, n) {
    return e /= n / 2, 1 > e ? s / 2 * e * e + t : (e--, -s / 2 * (e * (e - 2) - 1) + t);
}, SpectreDropdown.prototype.scrollTo_ = function(e, t, s) {
    e -= 70;
    var n, i = s.scrollTop, o = e - i, l = 0, r = 20;
    t = "undefined" == typeof t ? 500 : t;
    var a = function() {
        l += r, n = this.easeInOutQuad_(l, i, o, t), s.scrollTop = n, t > l && requestAnimationFrame(a);
    }.bind(this);
    a();
}, SpectreDropdown.prototype.findAncestor_ = function(e, t) {
    for (;e; ) {
        if (e.classList.contains(t)) return e;
        if (e === this.element_) return null;
        e = e.parentNode;
    }
    return null;
}, SpectreDropdown.prototype.spcDowngrade_ = function() {
    this.element_.removeEventListener("click", this.boundElementOnClick), this.element_.removeEventListener("change", this.boundInputOnChange), 
    this.element_.removeEventListener("keydown", this.boundElementOnKeyDown), this.element_.removeEventListener("blur", this.boundElementOnBlur, !0), 
    this.element_.removeEventListener("focus", this.boundElementOnFocus, !0);
}, componentHandler.register({
    constructor: SpectreDropdown,
    classAsString: "SpectreDropdown",
    cssClass: "spc-js-dropdown",
    widget: !0
});

var SpectreProgress = function(e) {
    this.element_ = e, this.init();
};

SpectreProgress.prototype.Constant_ = {}, SpectreProgress.prototype.CssClasses_ = {}, 
SpectreProgress.prototype.setProgress = function(e) {
    this.progressbar_.style.width = e + "%";
}, SpectreProgress.prototype.setBuffer = function(e) {
    this.bufferbar_.style.width = e + "%", this.auxbar_.style.width = 100 - e + "%";
}, SpectreProgress.prototype.init = function() {
    if (this.element_) {
        var e = document.createElement("div");
        e.className = "progressbar bar bar1", this.element_.appendChild(e), this.progressbar_ = e, 
        e = document.createElement("div"), e.className = "bufferbar bar bar2", this.element_.appendChild(e), 
        this.bufferbar_ = e, e = document.createElement("div"), e.className = "auxbar bar bar3", 
        this.element_.appendChild(e), this.auxbar_ = e, this.progressbar_.style.width = "0%", 
        this.bufferbar_.style.width = "100%", this.auxbar_.style.width = "0%", this.element_.classList.add("is-upgraded");
    }
}, SpectreProgress.prototype.spcDowngrade_ = function() {
    for (;this.element_.firstChild; ) this.element_.removeChild(this.element_.firstChild);
}, componentHandler.register({
    constructor: SpectreProgress,
    classAsString: "SpectreProgress",
    cssClass: "spc-js-progress",
    widget: !0
});

var SpectreRadio = function(e) {
    this.element_ = e, this.init();
};

SpectreRadio.prototype.Constant_ = {
    TINY_TIMEOUT: .001
}, SpectreRadio.prototype.CssClasses_ = {
    IS_FOCUSED: "is-focused",
    IS_DISABLED: "is-disabled",
    IS_CHECKED: "is-checked",
    IS_UPGRADED: "is-upgraded",
    JS_RADIO: "spc-js-radio",
    RADIO_BTN: "spc-radio__button",
    RADIO_OUTER_CIRCLE: "spc-radio__outer-circle",
    RADIO_INNER_CIRCLE: "spc-radio__inner-circle"
}, SpectreRadio.prototype.onChange_ = function(e) {
    for (var t = document.getElementsByClassName(this.CssClasses_.JS_RADIO), s = 0; s < t.length; s++) {
        var n = t[s].querySelector("." + this.CssClasses_.RADIO_BTN);
        n.getAttribute("name") === this.btnElement_.getAttribute("name") && t[s].SpectreRadio.updateClasses_();
    }
}, SpectreRadio.prototype.onFocus_ = function(e) {
    this.element_.classList.add(this.CssClasses_.IS_FOCUSED);
}, SpectreRadio.prototype.onBlur_ = function(e) {
    this.element_.classList.remove(this.CssClasses_.IS_FOCUSED);
}, SpectreRadio.prototype.onMouseup_ = function(e) {
    this.blur_();
}, SpectreRadio.prototype.updateClasses_ = function() {
    this.checkDisabled(), this.checkToggleState();
}, SpectreRadio.prototype.blur_ = function(e) {
    window.setTimeout(function() {
        this.btnElement_.blur();
    }.bind(this), this.Constant_.TINY_TIMEOUT);
}, SpectreRadio.prototype.checkDisabled = function() {
    this.btnElement_.disabled ? this.element_.classList.add(this.CssClasses_.IS_DISABLED) : this.element_.classList.remove(this.CssClasses_.IS_DISABLED);
}, SpectreRadio.prototype.checkToggleState = function() {
    this.btnElement_.checked ? this.element_.classList.add(this.CssClasses_.IS_CHECKED) : this.element_.classList.remove(this.CssClasses_.IS_CHECKED);
}, SpectreRadio.prototype.disable = function() {
    this.btnElement_.disabled = !0, this.updateClasses_();
}, SpectreRadio.prototype.enable = function() {
    this.btnElement_.disabled = !1, this.updateClasses_();
}, SpectreRadio.prototype.check = function() {
    this.btnElement_.checked = !0, this.updateClasses_();
}, SpectreRadio.prototype.uncheck = function() {
    this.btnElement_.checked = !1, this.updateClasses_();
}, SpectreRadio.prototype.init = function() {
    if (this.element_) {
        this.btnElement_ = this.element_.querySelector("." + this.CssClasses_.RADIO_BTN);
        var e = document.createElement("span");
        e.classList.add(this.CssClasses_.RADIO_OUTER_CIRCLE);
        var t = document.createElement("span");
        t.classList.add(this.CssClasses_.RADIO_INNER_CIRCLE), this.element_.appendChild(e), 
        this.element_.appendChild(t), this.btnElement_.addEventListener("change", this.onChange_.bind(this)), 
        this.btnElement_.addEventListener("focus", this.onFocus_.bind(this)), this.btnElement_.addEventListener("blur", this.onBlur_.bind(this)), 
        this.element_.addEventListener("mouseup", this.onMouseup_.bind(this)), this.updateClasses_(), 
        this.element_.classList.add(this.CssClasses_.IS_UPGRADED);
    }
}, componentHandler.register({
    constructor: SpectreRadio,
    classAsString: "SpectreRadio",
    cssClass: "spc-js-radio",
    widget: !0
});

var SpectreSwitch = function(e) {
    this.element_ = e, this.init();
};

SpectreSwitch.prototype.Constant_ = {
    TINY_TIMEOUT: .001
}, SpectreSwitch.prototype.CssClasses_ = {
    INPUT: "spc-switch__input",
    TRACK: "spc-switch__track",
    THUMB: "spc-switch__thumb",
    IS_FOCUSED: "is-focused",
    IS_DISABLED: "is-disabled",
    IS_CHECKED: "is-checked"
}, SpectreSwitch.prototype.onChange_ = function(e) {
    this.updateClasses_();
}, SpectreSwitch.prototype.onFocus_ = function(e) {
    this.element_.classList.add(this.CssClasses_.IS_FOCUSED);
}, SpectreSwitch.prototype.onBlur_ = function(e) {
    this.element_.classList.remove(this.CssClasses_.IS_FOCUSED);
}, SpectreSwitch.prototype.onMouseUp_ = function(e) {
    this.blur_();
}, SpectreSwitch.prototype.updateClasses_ = function() {
    this.checkDisabled(), this.checkToggleState();
}, SpectreSwitch.prototype.blur_ = function(e) {
    window.setTimeout(function() {
        this.inputElement_.blur();
    }.bind(this), this.Constant_.TINY_TIMEOUT);
}, SpectreSwitch.prototype.checkDisabled = function() {
    this.inputElement_.disabled ? this.element_.classList.add(this.CssClasses_.IS_DISABLED) : this.element_.classList.remove(this.CssClasses_.IS_DISABLED);
}, SpectreSwitch.prototype.checkToggleState = function() {
    this.inputElement_.checked ? this.element_.classList.add(this.CssClasses_.IS_CHECKED) : this.element_.classList.remove(this.CssClasses_.IS_CHECKED);
}, SpectreSwitch.prototype.disable = function() {
    this.inputElement_.disabled = !0, this.updateClasses_();
}, SpectreSwitch.prototype.enable = function() {
    this.inputElement_.disabled = !1, this.updateClasses_();
}, SpectreSwitch.prototype.on = function() {
    this.inputElement_.checked = !0, this.updateClasses_();
}, SpectreSwitch.prototype.off = function() {
    this.inputElement_.checked = !1, this.updateClasses_();
}, SpectreSwitch.prototype.init = function() {
    if (this.element_) {
        this.inputElement_ = this.element_.querySelector("." + this.CssClasses_.INPUT);
        var e = document.createElement("div");
        e.classList.add(this.CssClasses_.TRACK);
        var t = document.createElement("div");
        t.classList.add(this.CssClasses_.THUMB), this.element_.appendChild(e), this.element_.appendChild(t), 
        this.boundMouseUpHandler = this.onMouseUp_.bind(this), this.boundChangeHandler = this.onChange_.bind(this), 
        this.boundFocusHandler = this.onFocus_.bind(this), this.boundBlurHandler = this.onBlur_.bind(this), 
        this.inputElement_.addEventListener("change", this.boundChangeHandler), this.inputElement_.addEventListener("focus", this.boundFocusHandler), 
        this.inputElement_.addEventListener("blur", this.boundBlurHandler), this.element_.addEventListener("mouseup", this.boundMouseUpHandler), 
        this.updateClasses_(), this.element_.classList.add("is-upgraded");
    }
}, SpectreSwitch.prototype.spcDowngrade_ = function() {
    this.inputElement_.removeEventListener("change", this.boundChangeHandler), this.inputElement_.removeEventListener("focus", this.boundFocusHandler), 
    this.inputElement_.removeEventListener("blur", this.boundBlurHandler), this.element_.removeEventListener("mouseup", this.boundMouseUpHandler);
}, componentHandler.register({
    constructor: SpectreSwitch,
    classAsString: "SpectreSwitch",
    cssClass: "spc-js-switch",
    widget: !0
});

var SpectreTabs = function(e) {
    this.element_ = e, this.init();
};

SpectreTabs.prototype.Constant_ = {}, SpectreTabs.prototype.CssClasses_ = {
    TAB_CLASS: "spc-tabs__tab",
    BAR_CLASS: "spc-tabs__tab-bar",
    PANEL_CLASS: "spc-tabs__panel",
    LINE_CLASS: "spc-tabs__line",
    VERTICAL_CLASS: "spc-tabs--vertical",
    ACTIVE_CLASS: "is-active",
    UPGRADED_CLASS: "is-upgraded"
}, SpectreTabs.prototype.initTabs_ = function() {
    this.tabs_ = this.element_.querySelectorAll("." + this.CssClasses_.TAB_CLASS), this.tabbar_ = this.element_.querySelectorAll("." + this.CssClasses_.BAR_CLASS), 
    this.panels_ = this.element_.querySelectorAll("." + this.CssClasses_.PANEL_CLASS), 
    this.line_ = this.element_.querySelector("." + this.CssClasses_.LINE_CLASS);
    var e, t, s = this;
    for (t = 0; t < this.tabs_.length; t++) e = this.tabs_[t], new SpectreTab(e, this);
    setTimeout(function() {
        var e = s.element_.querySelector("." + s.CssClasses_.TAB_CLASS + "." + s.CssClasses_.ACTIVE_CLASS);
        e && s.resetLine_(e);
    }, 60), this.element_.classList.add(this.CssClasses_.UPGRADED_CLASS);
}, SpectreTabs.prototype.resetTabState_ = function() {
    for (var e = 0; e < this.tabs_.length; e++) this.tabs_[e].classList.remove(this.CssClasses_.ACTIVE_CLASS);
}, SpectreTabs.prototype.resetPanelState_ = function() {
    for (var e = 0; e < this.panels_.length; e++) this.panels_[e].classList.remove(this.CssClasses_.ACTIVE_CLASS);
}, SpectreTabs.prototype.resetLine_ = function(e) {
    if (e && this.line_) {
        var t = this.element_.classList.contains(this.CssClasses_.VERTICAL_CLASS);
        if (t) {
            var s = e.offsetTop, n = e.offsetHeight;
            this.line_.style.transform = "translateY(" + s + "px) scaleY(" + n + ")";
        } else {
            var i = e.offsetWidth, o = e.offsetLeft;
            this.line_.style.transform = "translateX(" + o + "px) scaleX(" + i + ")";
        }
    }
}, SpectreTabs.prototype.init = function() {
    this.element_ && this.initTabs_();
}, componentHandler.register({
    constructor: SpectreTabs,
    classAsString: "SpectreTabs",
    cssClass: "spc-js-tabs"
});

var SpectreTextfield = function(e) {
    this.element_ = e, this.maxRows = this.Constant_.NO_MAX_ROWS, this.stepValue = 1, 
    this.altStepValue = 5, this.isNumeric = !1, this.init();
};

SpectreTextfield.prototype.Constant_ = {
    NO_MAX_ROWS: -1,
    MAX_ROWS_ATTRIBUTE: "maxrows"
}, SpectreTextfield.prototype.CssClasses_ = {
    LABEL: "spc-textfield__label",
    INPUT: "spc-textfield__input",
    STEPPER: "spc-textfield__number",
    STEPUP: "spc-textfield__stepup",
    STEPDOWN: "spc-textfield__stepdown",
    IS_DIRTY: "is-dirty",
    IS_FOCUSED: "is-focused",
    IS_DISABLED: "is-disabled",
    IS_INVALID: "is-invalid",
    IS_UPGRADED: "is-upgraded"
}, SpectreTextfield.prototype.onKeyDown_ = function(e) {
    40 === e.keyCode ? (e.preventDefault(), this.onStepDown_(e)) : 38 === e.keyCode && (e.preventDefault(), 
    this.onStepUp_(e));
    var t = e.target.value.split("\n").length;
    13 === e.keyCode && this.maxRows !== this.Constant_.NO_MAX_ROWS && t >= this.maxRows && e.preventDefault();
}, SpectreTextfield.prototype.onWheel_ = function(e) {
    document.activeElement === e.target && (e.wheelDelta && e.wheelDelta < 0 ? (e.preventDefault(), 
    this.onStepDown_(e)) : e.wheelDelta && e.wheelDelta > 0 && (e.preventDefault(), 
    this.onStepUp_(e)));
}, SpectreTextfield.prototype.onKeyUp_ = function(e) {}, SpectreTextfield.prototype.onFocus_ = function(e) {
    this.element_.classList.add(this.CssClasses_.IS_FOCUSED);
}, SpectreTextfield.prototype.onBlur_ = function(e) {
    this.element_.classList.remove(this.CssClasses_.IS_FOCUSED), this.isNumeric && this.change(parseFloat(this.input_.value));
}, SpectreTextfield.prototype.onStepDown_ = function(e) {
    var t = parseFloat(this.input_.value);
    this.input_.value || (t = "undefined" != typeof this.minValue && null !== this.minValue ? 0 > this.minValue ? 0 : this.minValue : 0), 
    setTimeout(function() {
        this.input_.focus();
    }.bind(this), 0);
    var s = e.shiftKey ? this.altStepValue : this.stepValue;
    this.change(t - s);
}, SpectreTextfield.prototype.onStepUp_ = function(e) {
    var t = parseFloat(this.input_.value);
    this.input_.value || (t = "undefined" != typeof this.maxValue && null !== this.maxValue ? 0 < this.maxValue ? 0 : this.maxValue : 0), 
    setTimeout(function() {
        this.input_.focus();
    }.bind(this), 0);
    var s = e.shiftKey ? this.altStepValue : this.stepValue;
    this.change(t + s);
}, SpectreTextfield.prototype.updateClasses_ = function() {
    this.checkDisabled(), this.checkValidity(), this.checkDirty();
}, SpectreTextfield.prototype.checkDisabled = function() {
    this.input_.disabled ? this.element_.classList.add(this.CssClasses_.IS_DISABLED) : this.element_.classList.remove(this.CssClasses_.IS_DISABLED);
}, SpectreTextfield.prototype.checkValidity = function() {
    this.input_.validity.valid ? this.element_.classList.remove(this.CssClasses_.IS_INVALID) : this.element_.classList.add(this.CssClasses_.IS_INVALID);
}, SpectreTextfield.prototype.checkDirty = function() {
    this.input_.value && this.input_.value.length > 0 ? this.element_.classList.add(this.CssClasses_.IS_DIRTY) : this.element_.classList.remove(this.CssClasses_.IS_DIRTY);
}, SpectreTextfield.prototype.disable = function() {
    this.input_.disabled = !0, this.updateClasses_();
}, SpectreTextfield.prototype.enable = function() {
    this.input_.disabled = !1, this.updateClasses_();
}, SpectreTextfield.prototype.change = function(e) {
    (0 === e || e) && (this.isNumeric && (!isNaN(this.maxValue) && e > this.maxValue && (e = this.maxValue), 
    !isNaN(this.minValue) && e < this.minValue && (e = this.minValue)), Number(this.input_.value) !== e && setTimeout(function() {
        this.input_.dispatchEvent(new Event("change", {
            bubbles: !0
        }));
    }.bind(this), 0), this.input_.value = e), this.updateClasses_();
}, SpectreTextfield.prototype.init = function() {
    this.element_ && (this.label_ = this.element_.querySelector("." + this.CssClasses_.LABEL), 
    this.input_ = this.element_.querySelector("." + this.CssClasses_.INPUT), this.input_ && (this.input_.hasAttribute(this.Constant_.MAX_ROWS_ATTRIBUTE) && (this.maxRows = parseInt(this.input_.getAttribute(this.Constant_.MAX_ROWS_ATTRIBUTE), 10), 
    isNaN(this.maxRows) && (this.maxRows = this.Constant_.NO_MAX_ROWS)), this.element_.classList.contains(this.CssClasses_.STEPPER) && (this.observer = new MutationObserver(function(e) {
        e.forEach(function(e) {
            "max" === e.attributeName ? this.maxValue = parseFloat(this.input_.getAttribute("max")) : "min" === e.attributeName && (this.minValue = parseFloat(this.input_.getAttribute("min")));
        }.bind(this));
    }.bind(this)), this.observer.observe(this.input_, {
        attributes: !0
    }), this.isNumeric = !0, this.input_.setAttribute("pattern", "[0-9]*"), this.input_.setAttribute("inputmode", "numeric"), 
    this.minValue = parseFloat(this.input_.getAttribute("min")), this.maxValue = parseFloat(this.input_.getAttribute("max")), 
    this.stepValue = this.input_.getAttribute("step"), this.altStepValue = this.input_.getAttribute("alt-step"), 
    void 0 === this.stepValue || null === this.stepValue ? this.stepValue = 1 : isNaN(parseFloat(this.stepValue)) ? this.stepValue = 0 : this.stepValue = parseFloat(this.stepValue), 
    void 0 === this.altStepValue || null === this.altStepValue ? this.altStepValue = 5 : isNaN(parseFloat(this.altStepValue)) ? this.altStepValue = 0 : this.altStepValue = parseFloat(this.altStepValue), 
    this.stepup_ = this.element_.querySelector("." + this.CssClasses_.STEPUP), this.stepdown_ = this.element_.querySelector("." + this.CssClasses_.STEPDOWN), 
    this.boundStepUpHandler = this.onStepUp_.bind(this), this.boundStepDownHandler = this.onStepDown_.bind(this), 
    this.boundKeyDownHandler = this.onKeyDown_.bind(this), this.boundWheelHandler = this.onWheel_.bind(this), 
    this.stepup_.addEventListener("mousedown", this.boundStepUpHandler), this.stepdown_.addEventListener("mousedown", this.boundStepDownHandler), 
    this.input_.addEventListener("keydown", this.boundKeyDownHandler), this.input_.addEventListener("wheel", this.boundWheelHandler)), 
    this.boundUpdateClassesHandler = this.updateClasses_.bind(this), this.boundFocusHandler = this.onFocus_.bind(this), 
    this.boundBlurHandler = this.onBlur_.bind(this), this.boundKeyUpHandler = this.onKeyUp_.bind(this), 
    this.input_.addEventListener("input", this.boundUpdateClassesHandler), this.input_.addEventListener("focus", this.boundFocusHandler), 
    this.input_.addEventListener("blur", this.boundBlurHandler), this.maxRows !== this.Constant_.NO_MAX_ROWS, 
    this.updateClasses_(), this.element_.classList.add(this.CssClasses_.IS_UPGRADED)));
}, SpectreTextfield.prototype.spcDowngrade_ = function() {
    this.input_.removeEventListener("input", this.boundUpdateClassesHandler), this.input_.removeEventListener("focus", this.boundFocusHandler), 
    this.input_.removeEventListener("blur", this.boundBlurHandler), this.stepup_.removeEventListener("mousedown", this.boundStepUpHandler), 
    this.stepdown_.removeEventListener("mousedown", this.boundStepDownHandler), this.input_.removeEventListener("keydown", this.boundKeyDownHandler), 
    this.input_.removeEventListener("keyup", this.boundKeyUpHandler), this.input_.removeEventListener("wheel", this.boundWheelHandler), 
    this.observer.disconnect();
}, componentHandler.register({
    constructor: SpectreTextfield,
    classAsString: "SpectreTextfield",
    cssClass: "spc-js-textfield",
    widget: !0
});